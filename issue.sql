/*
MySQL Backup
Source Server Version: 5.7.23
Source Database: issue
Date: 2020/11/8 11:53:52
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
--  Table structure for `article`
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(255) NOT NULL DEFAULT '',
  `keywords` varchar(255) NOT NULL,
  `category` varchar(255) NOT NULL,
  `content` longtext NOT NULL,
  `status` tinyint(3) unsigned NOT NULL DEFAULT '1',
  `created_at` datetime NOT NULL,
  `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=38 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Table structure for `article_log`
-- ----------------------------
DROP TABLE IF EXISTS `article_log`;
CREATE TABLE `article_log` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
	`article_id` int(10) UNSIGNED NOT NULL,
	`mark` VARCHAR(20), 
  `created_at` datetime NOT NULL,
  `updated_at` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
--  Table structure for `groups`
-- ----------------------------
DROP TABLE IF EXISTS `groups`;
CREATE TABLE `groups` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `role_id` int(11) NOT NULL,
  `created_at` datetime NOT NULL,
  `updated_at` datetime NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_user_group` (`user_id`,`role_id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=51 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
--  Table structure for `job_count`
-- ----------------------------
DROP TABLE IF EXISTS `job_count`;
CREATE TABLE `job_count` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `job_title` varchar(30) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '职位名称，开发语言',
  `region` varchar(10) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '上海' COMMENT '地区',
  `amount` int(11) NOT NULL DEFAULT '0' COMMENT '职位数',
  `created_at` datetime NOT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_title` (`job_title`),
  KEY `idx_region` (`region`)
) ENGINE=InnoDB AUTO_INCREMENT=959 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
--  Table structure for `log`
-- ----------------------------
DROP TABLE IF EXISTS `log`;
CREATE TABLE `log` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `mark` varchar(255) DEFAULT NULL COMMENT '日志说明',
  `created_at` datetime NOT NULL,
  `updated_at` datetime NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=983 DEFAULT CHARSET=utf8;

-- ----------------------------
--  Table structure for `picture`
-- ----------------------------
DROP TABLE IF EXISTS `picture`;
CREATE TABLE `picture` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `pic_url` text COLLATE utf8mb4_unicode_ci NOT NULL,
  `status` tinyint(1) NOT NULL DEFAULT '1',
  `tag` varchar(255) COLLATE utf8mb4_unicode_ci DEFAULT '',
  `created_at` datetime NOT NULL,
  `updated_at` datetime NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------
--  Table structure for `role`
-- ----------------------------
DROP TABLE IF EXISTS `role`;
CREATE TABLE `role` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `groups` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '权限列表',
  `description` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '说明',
  `created_at` datetime NOT NULL,
  `updated_at` datetime NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_id` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='可以给一个角色很多权限，也可以通过很多角色组合来拥有很多权限';

-- ----------------------------
--  Table structure for `user`
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `mobile` varchar(255) NOT NULL DEFAULT '',
  `user_name` varchar(255) NOT NULL DEFAULT '',
  `password` varchar(255) NOT NULL DEFAULT '',
  `gender` varchar(255) NOT NULL DEFAULT '',
  `email` varchar(255) NOT NULL DEFAULT '',
  `addr` varchar(255) NOT NULL DEFAULT '',
  `status` int(11) NOT NULL DEFAULT '1',
  `description` varchar(255) NOT NULL DEFAULT '',
  `created_at` datetime NOT NULL,
  `updated_at` datetime NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_mobile_uniq` (`mobile`) USING BTREE,
  UNIQUE KEY `idx_id` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=33 DEFAULT CHARSET=utf8;

-- ----------------------------
--  Records 
-- ----------------------------
INSERT INTO `article` VALUES ('1','Go语言优势','','','### 一、部署简单。\nGo 编译生成的是一个静态可执行文件，除了 glibc 外没有其他外部依赖。这让部署变得异常方便：目标机器上只需要一个基础的系统和必要的管理、\n监控工具，完全不需要操心应用所需的各种包、库的依赖关系，大大减轻了维护的负担。这和 Python 有着巨大的区别。由于历史的原因，\nPython 的部署工具生态相当混乱【比如 setuptools, distutils, pip, buildout 的不同适用场合以及兼容性问题】。官方 PyPI 源又经常出问题，\n需要搭建私有镜像，而维护这个镜像又要花费不少时间和精力。\n### 二、并发性好。\nGoroutine 和 channel 使得编写高并发的服务端软件变得相当容易，很多情况下完全不需要考虑锁机制以及由此带来的各种问题。单个 Go 应用也能有效的利用多个 CPU 核，并行执行的性能好。这和 Python 也是天壤之比。多线程和多进程的服务端程序编写起来并不简单，而且由于全局锁 GIL 的原因，多线程的 Python 程序并不能有效利用多核，只能用多进程的方式部署；如果用标准库里的 multiprocessing 包又会对监控和管理造成不少的挑战【我们用的 supervisor 管理进程，对 fork 支持不好】。部署 Python 应用的时候通常是每个 CPU 核部署一个应用，这会造成不少资源的浪费，比如假设某个 Python 应用启动后需要占用 100MB 内存，而服务器有 32 个 CPU 核，那么留一个核给系统、运行 31 个应用副本就要浪费 3GB 的内存资源。\n### 三、良好的语言设计。\n从学术的角度讲 Go 语言其实非常平庸，不支持许多高级的语言特性；但从工程的角度讲，Go 的设计是非常优秀的：规范足够简单灵活，有其他语言基础的程序员都能迅速上手。更重要的是 Go 自带完善的工具链，大大提高了团队协作的一致性。比如 gofmt 自动排版 Go 代码，很大程度上杜绝了不同人写的代码排版风格不一致的问题。把编辑器配置成在编辑存档的时候自动运行 gofmt，这样在编写代码的时候可以随意摆放位置，存档的时候自动变成正确排版的代码。此外还有 gofix, govet 等非常有用的工具。\n### 四、执行性能好。\n虽然不如 C 和 Java，但通常比原生 Python 应用还是高一个数量级的，适合编写一些瓶颈业务。内存占用也非常省。','1','2018-10-24 11:42:33','2020-07-21 18:05:16'), ('2','各平台mysql重启','','','linux平台及windows平台mysql重启方法\n\n　　Linux下重启MySQL的正确方法：\n\n　　1、通过rpm包安装的MySQL\n\n　　service mysqld restart\n\n　　2、从源码包安装的MySQL\n\n　　// linux关闭MySQL的命令\n\n　　$mysql_dir/bin/mysqladmin -uroot -p shutdown\n\n　　// linux启动MySQL的命令\n\n　　$mysql_dir/bin/mysqld_safe &\n\n　　其中mysql_dir为MySQL的安装目录，mysqladmin和mysqld_safe位于MySQL安装目录的bin目录下，很容易找到的。\n\n　　3、以上方法都无效的时候，可以通过强行命令：“killall mysql”来关闭MySQL，但是不建议用这样的方式，因为这种野蛮的方法会强行终止MySQL数据库服务，有可能导致表损坏\n\n　　步骤或方法:RedHat Linux (Fedora Core/Cent OS)\n\n　　1.启动：/etc/init.d/mysqld start\n\n　　2.停止：/etc/init.d/mysqld stop\n\n　　3.重启：/etc/init.d/mysqld restart\n\n　　Debian / Ubuntu Linux\n\n　　1.启动：/etc/init.d/mysql start\n\n　　2.停止：/etc/init.d/mysql stop\n\n　　3.重启：/etc/init.d/mysql restart\n\n　　Windows\n\n　　1.点击“开始”->“运行”(快捷键Win+R)。\n\n　　2.启动：输入 net stop mysql\n\n　　3.停止：输入 net start mysql\n\n　　提示* Redhat Linux 也支持service command，启动：# service mysqld start 停止：# service mysqld stop 重启：# service mysqld restart\n\n　　* Windows下不能直接重启(restart)，只能先停止，再启动。\n\n　　MySQL启动，停止，重启方法：\n\n　　一、启动方式\n\n　　1、使用 service 启动：service mysqld start\n\n　　2、使用 mysqld 脚本启动：/etc/inint.d/mysqld start\n\n　　3、使用 safe_mysqld 启动：safe_mysqld&\n\n　　二、停止\n\n　　1、使用 service 启动：service mysqld stop\n\n　　2、使用 mysqld 脚本启动：/etc/inint.d/mysqld stop\n\n　　3、mysqladmin shutdown\n\n　　三、重启\n\n　　1、使用 service 启动：service mysqld restart\n\n　　2、使用 mysqld 脚本启动：/etc/inint.d/mysqld restart','1','2018-10-11 16:47:02','2020-01-17 20:06:04'), ('6','说道说道前后端分离 ','','','\n要说前端界的发展速度，那真是快！\n\n2012年那时候接触过extjs，用于企业级后台开发还真不错，有好看的UI界面，组件丰富，基本能满足各类需求。但此时，HTML5正在蓬勃发展，尤其是乔布斯宣布苹果设备不支持flash后HTML5发展更是迅猛。并且angularjs这类MVVM框架被大多数所知，reactjs,vuejs如雨后春笋般生长。\n\n2014年使用了一段时间angularjs，感觉学习难度有点大，2015年使用vue1.0做了一个项目后我逢人就说angular，vue有多好用，推荐他们放弃jquery使用vue。不到2年时间再看看前端界，vue，react等框架已经是前端开发标配，如果你说公司项目还在使用jquery会被人笑话，对于前端新人MVVM框架是必学，jquery反而不会重视。\n\n这就导致一个结果：“手里拿着锤子，看什么都是钉子”，因为有锤子的关系，遇到任何问题，都会先想如何用锤子解决。久而久之，陷入了一种思维定式。任何工具带来便利的同时，也带来了局限性。而这往往是用锤子的人很难看到的。就拿一个需要SEO的网站来说，该选择哪种技术好？如果只会vue，不熟悉jquery的人来说肯定是选择vue，就算vue不太适合做这类网站，也会拿出ssr来强行做事。殊不知需要SEO的网站使用静态文件是最合适的。大多数人认为前后端分离是使用vue，react，angular，使用jquery的不叫前后端分离，这完全是搞混了概念，实际上后端的controller层也属于视图层，也可以归属于前端。\n\n现在去网上一搜，问一下身边的人怎么看待前后端分离的，大多数人秉持着支持的态度，认为前后端分离好处多多，列举几条：\n\n- 专业的人做专业的事\n- 前后并行开发，效率高\n- 前端工程化，组件化\n- 解耦\n- 降低了开发学习难度\n\n![](http://hopefully-img.yuedun.wang/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20180805104325.jpg)\n\n等等……\n\n大家说的都说到点上了，这也是前后端分离能发展起来的驱动力。但是道理说的都挺好，如果不结合实际情况的话就是大炮打蚊子，不但达不到理想的效果还浪费资源。而且前后端分离带来的负面情况也不可忽视：\n\n- 增加了沟通成本，一些前后端都可以做又都不想做的事或许只能由权利大的来决定。\n- 一般前端开发速度会比后端快，在接口没开发好时前端只能闲等着。也有反过来的情况。前后端分离也意味着任务关联性减弱，可能不是同时开发，需要一方催着一方来完成。\n- 跨域问题导致联调困难，前端只能等待接口开发上了服务器才能调试。\n- 职责分离后确认职责也困难，一个问题出现到底是谁的问题？谁解决？\n- 一个需求需要前后端开发同时参与理解需求，有理解偏差问题。\n- 小公司多一个人多一份支出。\n\n那么到底该不该进行前后端分离，如何进行技术选型？这需要根据一些实际情况来决定，大体判断准则有以下几点：\n\n- 后台系统采用前后端分离比较合适。\n- 需要SEO引流的就不要强行前后端分离了，react，vue的服务端渲染也很勉强，徒增开发难度而已。\n- 数据交互比较多的使用前后端分离，操作数据比jquery方便。\n- 页面本身特别简单，只负责简单数据展示，要求打开速度，直接服务端渲染即可。这种页面本身就是单页面，如果还要使用框架就是多此一举，增加页面负担，增加开发调试难度。\n- 开发资源充足最好前后端分离，开发资源不足时不分离，一人包揽前后台端反而更快。\n\n最后，前后端分离是一个趋势，但不是必须。更准确的说法应该叫做“前后端分工”，毕竟在5年前这些活都是一个开发来做的，因为技术复杂性提升，前端不想只是切图，后端不想学变化太快的前端就出现了分离。你可以想象测试的工作，现在的测试大多还是测业务，但是也出现了一个自动化测试的职位，因为测试不想天天鼠标点呀点的测，想搞点高深的东西，而开发又特别烦写单元测试代码，这就又出现分离。再者，数据库也是一样，所以出现了DBA这个角色。谁知哪一天又会合起来呢！\n','1','2019-03-01 14:21:34','2020-07-22 13:42:28'), ('7','使用pm2作为golang的守护进程','','','开发过nodejs的人对于pm2再熟悉不过了，而pm2不止可以作为nodejs的守护进程，\n\n同样可以用在golang上，使用方法同样很简单：\n\n> pm2 start bin\n\n直接启动go二进制文件即可。\n\n[https://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/](https://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/#start-an-app)','1','2019-01-16 17:18:42','2019-01-16 14:43:01'), ('8','gRPC','','','<p>\n\n</p><h3><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a>概述</h3><p>gRPC 一开始由 google 开发，是一款语言中立、平台中立、开源的远程过程调用(RPC)系统。</p><p>在 gRPC 里客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法，使得您能够更容易地创建分布式应用和服务。与许多 RPC 系统类似，gRPC 也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC <a target=\"_blank\" rel=\"nofollow\" href=\"https://www.baidu.com/s?wd=%E6%9C%8D%E5%8A%A1%E5%99%A8&amp;amp;tn=24004469_oem_dg&amp;amp;rsv_dl=gh_pl_sl_csd\">服务器</a>来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。</p><p><img alt=\"\" src=\"https://img-blog.csdn.net/20171019113619182?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHVkdW9ydWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\"></p><h3><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a>特性</h3><ul><li><strong>基于HTTP/2</strong>&nbsp;<br>HTTP/2 提供了连接多路复用、双向流、服务器推送、请求优先级、首部压缩等机制。可以节省带宽、降低TCP链接次数、节省CPU，帮助移动设备延长电池寿命等。gRPC 的协议设计上使用了HTTP2 现有的语义，请求和响应的数据使用HTTP Body 发送，其他的控制信息则用Header 表示。</li><li><strong>IDL使用ProtoBuf</strong>&nbsp;<br>gRPC使用ProtoBuf来定义服务，ProtoBuf是由Google开发的一种数据序列化协议（类似于XML、JSON、hessian）。ProtoBuf能够将数据进行序列化，并广泛应用在数据存储、通信协议等方面。压缩和传输效率高，语法简单，表达力强。</li><li><strong>多语言支持</strong>（C, C++, Python, PHP, Nodejs, C#, Objective-C、Golang、Java） <br>gRPC支持多种语言，并能够基于语言自动生成客户端和服务端功能库。目前已提供了C版本grpc、Java版本grpc-java 和 Go版本grpc-go，其它语言的版本正在积极开发中，其中，grpc支持C、C++、Node.js、Python、Ruby、Objective-C、PHP和C#等语言，grpc-java已经支持Android开发。</li></ul><p>gRPC已经应用在Google的云服务和对外提供的API中，其主要应用场景如下： <br>- 低延迟、高扩展性、分布式的系统<br>- 同云服务器进行通信的移动应用客户端<br>- 设计语言独立、高效、精确的新协议<br>- 便于各方面扩展的分层设计，如认证、负载均衡、日志记录、监控等</p><h3><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a>HTTP2.0 特性</h3><p>HTTP/2，也就是超文本传输协议第2版，不论是1还是2，HTTP的基本语义是不变的，比如方法语义（GET/PUST/PUT/DELETE），状态码（200/404/500等），Range Request，Cacheing，Authentication、URL路径， 不同的主要是下面几点：</p><p>多路复用 (Multiplexing)</p><p>在 HTTP/1.1 协议中 「浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞」。</p><p>HTTP/2 的多路复用(Multiplexing) 则允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。 <br>因此 HTTP/2 可以很容易的去实现多流并行而不用依赖建立多个 TCP 连接，HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行地在同一个 TCP 连接上双向交换消息。</p><p><img alt=\"\" src=\"https://img-blog.csdn.net/20171019105033713?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHVkdW9ydWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\"></p><p>二进制帧</p><p>HTTP/2 传输的数据是二进制的。相比 HTTP/1.1 的纯文本数据，二进制数据一个<a target=\"_blank\" rel=\"nofollow\" href=\"https://www.baidu.com/s?wd=%E6%98%BE%E8%80%8C%E6%98%93%E8%A7%81&amp;amp;tn=24004469_oem_dg&amp;amp;rsv_dl=gh_pl_sl_csd\">显而易见</a>的好处是：更小的传输体积。这就意味着更低的负载。二进制的帧也更易于解析而且不易出错，纯文本帧在解析的时候还要考虑处理空格、大小写、空行和换行等问题，而二进制帧就不存在这个问题。</p><p><img alt=\"\" src=\"https://img-blog.csdn.net/20171019105519131?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHVkdW9ydWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\"></p><p>首部压缩（Header Compression）</p><p>HTTP是无状态协议。简而言之，这意味着每个请求必须要携带服务器需要的所有细节，而不是让服务器保存住之前请求的元数据。因为http2没有改变这个范式，所以它也需要这样（携带所有细节），因此 HTTP 请求的头部需要包含用于标识身份的数据比如 cookies，而这些数据的量也在随着时间增长。每一个请求的头部都包含这些大量的重复数据，无疑是一种很大的负担。对请求头部进行压缩，将会大大减轻这种负担，尤其对移动端来说，性能提高非常明显。</p><p>HTTP/2 使用的压缩方式是 HPACK。 <a target=\"_blank\" rel=\"nofollow\" href=\"http://http2.github.io/http2-spec/compression.html\">http://http2.github.io/http2-spec/compression.html</a></p><p>HTTP2.0在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键-值对，对于相同的数据，不再通过每次请求和响应发送；通信期间几乎不会改变的通用键-值对（用户代理、可接受的媒体类型，等等）只需发送一次。</p><p><img alt=\"\" src=\"https://img-blog.csdn.net/20171019105927130?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHVkdW9ydWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\"></p><p>事实上,如果请求中不包含首部（例如对同一资源的轮询请求），那么首部开销就是零字节。此时所有首部都自动使用之前请求发送的首部。</p><p>如果首部发生变化了，那么只需要发送变化了数据在Headers帧里面，新增或修改的首部帧会被追加到“首部表”。首部表在 HTTP2.0的连接存续期内始终存在,由客户端和服务器共同渐进地更新。</p><p>服务端推送（Server Push）</p><p>HTTP/2 的服务器推送所作的工作就是，服务器在收到客户端对某个资源的请求时，会判断客户端<a target=\"_blank\" rel=\"nofollow\" href=\"https://www.baidu.com/s?wd=%E5%8D%81%E6%9C%89%E5%85%AB%E4%B9%9D&amp;amp;tn=24004469_oem_dg&amp;amp;rsv_dl=gh_pl_sl_csd\">十有八九</a>还要请求其他的什么资源，然后一同把这些资源都发送给客户端，即便客户端还没有明确表示它需要这些资源。</p><p>客户端可以选择把额外的资源放入缓存中（所以这个特点也叫 Cache push），也可以选择发送一个 RST_STREAM frame 拒绝任何它不想要的资源。</p><p><img alt=\"\" src=\"https://img-blog.csdn.net/20171019110237588?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHVkdW9ydWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\"></p><p>主动重置链接</p><p>Length的HTTP消息被送出之后，我们就很难中断它了。当然，通常我们可以断开整个TCP链接（但也不总是可以这样），但这样导致的代价就是需要重新通过三次握手建立一个新的TCP连接。</p><p>HTTP/2 引入了一个 RST_STREAM frame 来让客户端在已有的连接中发送重置请求，从而中断或者放弃响应。当浏览器进行页面跳转或者用户取消下载时，它可以防止建立新连接，避免浪费所有带宽。</p><h3><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a>与其他rpc比较</h3><p>与thrift,dubbo,motan等比较</p><div>*MotanDubboxthriftgRPCrpcx开发语言JavaJava跨语言跨语言go分布式服务治理YY可以配合zookeeper, Eureka等实现可以配合etcd(go),zookeeper,consul等实现自带服务注册中心，也支持zookerper,etcd等发现方式底层协议motan协议，使用tcp长连接Dubbo 协议、 Rmi 协议、 Hessian 协议、 HTTP 协议、 WebService 协议、Dubbo Thrift 协议、Memcached 协议tpc/http/framehttp2tcp长链接消息序列化hessian2,jsonhessian2,json,resr,kyro,FST等，可扩展protobuf等thriftprotobufGob、Json、MessagePack、gencode、ProtoBuf等跨语言编程N(支持php client和c server)NYYN负载均衡ActiveWeight 、Random 、 RoundRobin 、LocalFirst 、 Consistent 、ConfigurableWeightRandom 、RoundRobin 、ConsistentHash 、 LeastActiveHaproxy, zookerper+客户端负载均衡等方案负载均衡软件HaProxy等支持随机请求、轮询、低并发优先、一致性 Hash等容错Failover 失效切换、Failfast 快速失败Failover 、 Failfast 、Failsafe 、 Failback 、 Forking、 BroadcastFailover具有 Failover 失效切换的容错策略失败重试（Failover）、快速失败（Failfast）注册中心consulzookeeperzookeeperetcd,zookeeper,consulzookerper,etcd性能★★★★★★★★ 比grpc快2-5倍★★★ 比dubbox,motan快★★★★★ 比thrift快1-1.5倍侧重优势服务管理服务管理跨语言，性能++跨语言，性能性能++，服务治理客户端异步调用方案 &nbsp;<ul><li>使用thrift IDL “oneway” 关键字(无返回结果)，+callback <br>tcp异步请求<br>- thrift IDL<code>参数</code>不支持函数或服务</li></ul>stream传输，双向通信 服务端异步处理 &nbsp;1、TNonblockingServer(java/c++,php); THsHaServer(java/c++); TThreadpoolServer(java/c++); TThreadSelectorServer(java/c++)<br>2、结合消息队列或中间件<br>3、swoole/goroutine等多任务支持同上，使用stream传输。Stream对象在传输过程中会被当做集合，用Iterator来遍历处理 </div><p>grpc vs thrift:</p><p><img alt=\"\" src=\"https://img-blog.csdn.net/20171019112530367?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHVkdW9ydWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\"></p><p>使用gRPC的公司或项目：</p><p>Google <br>Mochi中国<br>阿里OTS<br>腾讯部分部门<br>Tensorflow项目中使用了grpc<br>CoreOS — Production API for etcd v3 is entirely gRPC. etcd v3的接口全部使用grpc<br>Square — replacement for all of their internal RPC. one of the very first adopters and contributors to gRPC.<br>ngrok — all 20+ internal services communicate via gRPC 一个内网转发产品<br>Netflix<br>Yik Yak<br>VSCO<br>Cockroach</p><p>使用Thrift的公司或项目：</p><p>Facebook <br>雪球<br>饿了么<br><a target=\"_blank\" rel=\"nofollow\" href=\"https://www.baidu.com/s?wd=%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1&amp;amp;tn=24004469_oem_dg&amp;amp;rsv_dl=gh_pl_sl_csd\">今日头条</a>&nbsp;<br>evernote<br>友盟<br>小米<br>美团<br>Quora<br>Twitter<br>Pinterest<br>Foursquare<br>Maxeler Technologies</p><p>gRPC优缺点：</p><p>优点：</p><p>protobuf二进制消息，性能好/效率高（空间和时间效率都很不错） <br>proto文件生成目标代码，简单易用<br>序列化反序列化直接对应程序中的数据类，不需要解析后在进行映射(XML,JSON都是这种方式)<br>支持向前兼容（新加字段采用默认值）和向后兼容（忽略新加字段），简化升级<br>支持多种语言（可以把proto文件看做IDL文件）<br>Netty等一些框架集成</p><p>缺点：</p><p>1）GRPC尚未提供连接池，需要自行实现 <br>2）尚未提供“服务发现”、“负载均衡”机制<br>3）因为基于HTTP2，绝大部多数HTTP Server、Nginx都尚不支持，即Nginx不能将GRPC请求作为HTTP请求来负载均衡，而是作为普通的TCP请求。（nginx1.9版本已支持）<br>4） Protobuf二进制可读性差（貌似提供了Text_Fromat功能）<br>默认不具备动态特性（可以通过动态定义生成消息类型或者动态编译支持）</p><p>grpc坑：</p><p>来自<a target=\"_blank\" rel=\"nofollow\" href=\"https://news.ycombinator.com/item?id=12345223\">https://news.ycombinator.com/item?id=12345223</a>的网友： <br>http2只允许单个链接传输10亿流数据。原因在于：<br>htt2使用31位整形标示流，服务端使用奇数，客户端使用偶数，所以总共10亿可用。</p><pre><code><ol><li><div><div>&nbsp;</div></div><div><div>HTTP/2.0 uses an unsigned 31-bit integer to identity individual streams over a connection.</div></div></li><li><div><div>&nbsp;</div></div><div><div>Server-initiated streams must use even identifiers. </div></div></li><li><div><div>&nbsp;</div></div><div><div>Client-initiated streams must use odd identifiers.</div></div></li></ol></code></pre><p>解决思路：超过一定数量的流，需要重启链接。</p><h3><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a>gRPC通信方式</h3><p>gRPC有四种通信方式: <br>1、 Simple RPC<br>简单rpc<br>这就是一般的rpc调用，一个请求对象对应一个返回对象<br>proto语法：</p><pre><code>rpc simpleHello(Person) returns (Result) {}</code></pre><br><p>2、 Server-side streaming RPC <br>服务端流式rpc<br>一个请求对象，服务端可以传回多个结果对象<br>proto语法</p><pre><code>rpc serverStreamHello(Person) returns (stream Result) {}</code></pre><br><p>3、 Client-side streaming RPC <br>客户端流式rpc<br>客户端传入多个请求对象，服务端返回一个响应结果<br>proto语法</p><pre><code>rpc clientStreamHello(stream Person) returns (Result) {}</code></pre><p>4、 Bidirectional streaming RPC <br>双向流式rpc<br>结合客户端流式rpc和服务端流式rpc，可以传入多个对象，返回多个响应对象<br>proto语法</p><pre><code>rpc biStreamHello(stream Person) returns (stream Result) {}</code></pre><h3><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a>服务定义及ProtoBuf</h3><p>gRPC使用ProtoBuf定义服务， 我们可以一次性的在一个 .proto 文件中定义服务并使用任何支持它的语言去实现客户端和服务器，反过来，它们可以在各种环境中，从云服务器到你自己的平板电脑—— gRPC 帮你解决了不同语言及环境间通信的复杂性。使用 protocol buffers 还能获得其他好处，包括高效的序列号，简单的 IDL 以及容易进行接口更新。</p><p>protoc编译工具</p><p>protoc工具可在<a target=\"_blank\" rel=\"nofollow\" href=\"https://github.com/google/protobuf/releases\">https://github.com/google/protobuf/releases</a>&nbsp;下载到源码。 <br>linux下安装</p><p>protobuf语法</p><p>1、syntax = “proto3”; <br>文件的第一行指定了你使用的是proto3的语法：如果你不指定，protocol buffer 编译器就会认为你使用的是proto2的语法。这个语句必须出现在.proto文件的非空非注释的第一行。<br>2、message SearchRequest {……}<br>message 定义实体，c/c++/go中的结构体，php中类<br>3、基本数据类型<br><img alt=\"\"></p><p>4、注释符号： 双斜线，如：//xxxxxxxxxxxxxxxxxxx <br>5、字段唯一数字标识（用于在二进制格式中识别各个字段，上线后不宜再变动）：Tags<br>1到15使用一个字节来编码，包括标识数字和字段类型（你可以在Protocol Buffer 编码中查看更多详细）；16到2047占用两个字节。因此定义proto文件时应该保留1到15，用作出现最频繁的消息类型的标识。记得为将来会继续增加并可能频繁出现的元素留一点儿标识区间，也就是说，不要一下子把1—15全部用完，为将来留一点儿。<br>标识数字的合法范围：最小是1，最大是 229 - 1，或者536,870,911。<br>另外，不能使用19000 到 19999之间的数字(FieldDescriptor::kFirstReservedNumber through FieldDescriptor::kLastReservedNumber)，因为它们被Protocol Buffers保留使用<br>6、字段修饰符：<br>required：值不可为空<br>optional：可选字段<br>singular：符合语法规则的消息包含零个或者一个这样的字段（最多一个）<br>repeated：一个字段在合法的消息中可以重复出现一定次数（包括零次）。重复出现的值的次序将被保留。在proto3中，重复出现的值类型字段默认采用压缩编码。你可以在这里找到更多关于压缩编码的东西： Protocol Buffer Encoding。<br>默认值： optional PhoneType type = 2 [default = HOME];<br>proto3中，省略required,optional,singular，由protoc自动选择。<br>7、代理类生成<br>1)、C++, 每一个.proto 文件可以生成一个 .h 文件和一个 .cc 文件<br>2)、Java, 每一个.proto文件可以生成一个 .java 文件<br>3)、Python, 每一个.proto文件生成一个模块，其中为每一个消息类型生成一个静态的描述器，在运行时，和一个metaclass一起使用来创建必要的Python数据访问类<br>4)、Go, 每一个.proto生成一个 .pb.go 文件<br>5)、Ruby, 每一个.proto生成一个 .rb 文件<br>6)、Objective-C, 每一个.proto 文件可以生成一个 pbobjc.h 和一个pbobjc.m 文件<br>7)、C#, 每一个.proto文件可以生成一个.cs文件.<br>8)、php, 每一个message消息体生成一个.php类文件，并在GPBMetadata目录生成一个对应包名的.php类文件，用于保存.proto的二进制元数据。<br>8、字段默认值<br>- strings, 默认值是空字符串（empty string）<br>- bytes, 默认值是空bytes（empty bytes）<br>- bools, 默认值是false<br>- numeric, 默认值是0<br>- enums, 默认值是第一个枚举值（value必须为0）<br>- message fields, the field is not set. Its exact value is langauge-dependent. See the generated code guide for details.<br>- repeated fields，默认值为empty，通常是一个空list<br>9、枚举</p><pre><code><ol><li><div><div>&nbsp;</div></div><div><div>// 枚举类型，必须从0开始，序号可跨越。同一包下不能重名，所以加前缀来区别</div></div></li><li><div><div>&nbsp;</div></div><div><div>enum WshExportInstStatus {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    INST_INITED = 0;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    INST_RUNNING = 1;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    INST_FINISH = 2;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    INST_FAILED = 3;</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li></ol></code></pre><p>10、Maps字段类型</p><pre><code>map&lt;key_type, value_type&gt; map_field = N;</code></pre><br><p>其中key_type可以是任意Integer或者string类型（所以，除了floating和bytes的任意标量类型都是可以的）value_type可以是任意类型。 <br>例如，如果你希望创建一个project的映射，每个Projecct使用一个string作为key，你可以像下面这样定义：</p><pre><code>map&lt;string, Project&gt; projects = 3;</code></pre><ul><li>Map的字段可以是repeated。</li><li>序列化后的顺序和map迭代器的顺序是不确定的，所以你不要期望以固定顺序处理Map</li><li>当为.proto文件产生生成文本格式的时候，map会按照key 的顺序排序，数值化的key会按照数值排序。</li><li>从序列化中解析或者融合时，如果有重复的key则后一个key不会被使用，当从文本格式中解析map时，如果存在重复的key。</li></ul><p>11、默认值 <br>字符串类型默认为空字符串<br>字节类型默认为空字节<br>布尔类型默认false<br>数值类型默认为0值<br>enums类型默认为第一个定义的枚举值，必须是0</p><p>12、服务 <br>服务使用service{}包起来，每个方法使用rpc起一行申明，一个方法包含一个请求消息体和一个返回消息体</p><pre><code><ol><li><div><div>&nbsp;</div></div><div><div>service HelloService {</div></div></li><li><div><div>&nbsp;</div></div><div><div>  rpc SayHello (HelloRequest) returns (HelloResponse);</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div>message HelloRequest {</div></div></li><li><div><div>&nbsp;</div></div><div><div>  string greeting = 1;</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>message HelloResponse {</div></div></li><li><div><div>&nbsp;</div></div><div><div>  string reply = 1;</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li></ol></code></pre><p><a target=\"_blank\" rel=\"nofollow\" href=\"https://developers.google.com/protocol-buffers/docs/reference/overview?hl=zh-cn\">更多protobuf参考(google)</a>&nbsp;<br><a target=\"_blank\" rel=\"nofollow\" href=\"http://blog.csdn.net/u011518120/article/details/54604615\">更多protobuf参考(csdn)</a></p><h2><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a>golang中使用gRPC</h2><p>前期准备</p><pre><code><ol><li><div><div>&nbsp;</div></div><div><div>go get -u \"google.golang.org/grpc\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>go get -u \"google.golang.org/grpc/reflection\"</div></div></li></ol></code></pre><ul><li>1</li><li>2</li></ul><p>例如我定义的文件exporttask.proto：</p><pre><code><ol><li><div><div>&nbsp;</div></div><div><div>// 微生活导出服务</div></div></li><li><div><div>&nbsp;</div></div><div><div>// 导出功能接口</div></div></li><li><div><div>&nbsp;</div></div><div><div>/*</div></div></li><li><div><div>&nbsp;</div></div><div><div>    1、 创建任务模板</div></div></li><li><div><div>&nbsp;</div></div><div><div>    2、 查询、列出任务模板</div></div></li><li><div><div>&nbsp;</div></div><div><div>    3、 删除任务模板</div></div></li><li><div><div>&nbsp;</div></div><div><div>    4、 添加导出任务实例</div></div></li><li><div><div>&nbsp;</div></div><div><div>    5、 查询任务状态</div></div></li><li><div><div>&nbsp;</div></div><div><div>*/</div></div></li><li><div><div>&nbsp;</div></div><div><div>syntax = \"proto3\";</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// java 语法特别选项</div></div></li><li><div><div>&nbsp;</div></div><div><div>option java_multiple_files = true;</div></div></li><li><div><div>&nbsp;</div></div><div><div>option java_package = \"io.grpc.welife.WshExportTask\";</div></div></li><li><div><div>&nbsp;</div></div><div><div>option java_outer_classname = \"WshExportTask\";</div></div></li><li><div><div>&nbsp;</div></div><div><div>// 包名 golang包名，php中namespase,</div></div></li><li><div><div>&nbsp;</div></div><div><div>package exporttask;</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// 导出任务服务定义</div></div></li><li><div><div>&nbsp;</div></div><div><div>service ExportTask {</div></div></li><li><div><div>&nbsp;</div></div><div><div>  // 创建任务模板</div></div></li><li><div><div>&nbsp;</div></div><div><div>  rpc CreateTpl(WshExportTaskCreateTplReq) returns (WshExportTaskCreateTplRes) {}</div></div></li><li><div><div>&nbsp;</div></div><div><div>  // 查询任务模板</div></div></li><li><div><div>&nbsp;</div></div><div><div>  rpc ListTpl(WshExportTaskListTplReq) returns (WshExportTaskListTplRes) {}</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// 枚举类型，必须从0开始，序号可跨越。同一包下不能重名，所以加前缀来区别</div></div></li><li><div><div>&nbsp;</div></div><div><div>enum WshExportTplStatus {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    TPL_INITED = 0;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    TPL_NORMAL = 1;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    TPL_DELETED = 9;</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>enum WshExportFormat {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    FMT_DEFAULT = 0;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    FMT_CSV = 1;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    FMT_XLS = 2;</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>message WshExportTpl {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    string etplName = 1;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    string etplTag = 2;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    WshExportFormat etplOutputFormat = 3;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    string etplOutputColumns = 4;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    string etplExpr = 5;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    int32 etplId = 6;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    int32 etplExecTimes = 7;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    int32 etplExecOkTimes = 8;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    int32 etplStatus = 9;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    string etplCreated = 10;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    string etplUpdated = 11;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    string etplDeleted = 12;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    int32 operatorId = 13;</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>message WshExportTaskCreateTplReq {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    string etplName = 1;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    string etplTag = 2;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    string etplExpr = 3;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    string etplOutputColumns = 4;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    WshExportFormat etplOutputFormat = 5;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    int32 operatorId = 6;</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>message WshExportTaskCreateTplRes {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    string errCode = 1;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    string errMsg = 2;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    WshExportTpl data = 3;</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>message WshExportTaskListTplReq {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    int32 etplId = 1;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    string etplName = 2;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    string etplTag = 3;</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// repeated 表示数组</div></div></li><li><div><div>&nbsp;</div></div><div><div>message WshExportTaskListTplRes {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    string errCode = 1;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    string errMsg = 2;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    repeated WshExportTpl data = 3;</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li></ol></code></pre><p>使用protoc命令生成golang对应的rpc代码：</p><pre><code><ol><li><div><div>&nbsp;</div></div><div><div>#格式 protoc --go_out=plugins=grpc:{go代码输出路径} {proto文件}</div></div></li><li><div><div>&nbsp;</div></div><div><div>protoc --go_out=plugins=grpc:./ ./exporttask.proto</div></div></li></ol></code></pre><p>生成对应当exporttask.pb.go</p><pre><code><ol><li><div><div>&nbsp;</div></div><div><div>// Code generated by protoc-gen-go. DO NOT EDIT.</div></div></li><li><div><div>&nbsp;</div></div><div><div>// source: exporttask.proto</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>/*</div></div></li><li><div><div>&nbsp;</div></div><div><div>Package exporttask is a generated protocol buffer package.</div></div></li><li><div><div>&nbsp;</div></div><div><div>&nbsp;</div></div></li><li><div><div>&nbsp;</div></div><div><div>包名 golang包名，php中namespase,</div></div></li><li><div><div>&nbsp;</div></div><div><div>&nbsp;</div></div></li><li><div><div>&nbsp;</div></div><div><div>It is generated from these files:</div></div></li><li><div><div>&nbsp;</div></div><div><div>    exporttask.proto</div></div></li><li><div><div>&nbsp;</div></div><div><div>&nbsp;</div></div></li><li><div><div>&nbsp;</div></div><div><div>It has these top-level messages:</div></div></li><li><div><div>&nbsp;</div></div><div><div>    WshExportTpl</div></div></li><li><div><div>&nbsp;</div></div><div><div>    WshExportTaskCreateTplReq</div></div></li><li><div><div>&nbsp;</div></div><div><div>    WshExportTaskCreateTplRes</div></div></li><li><div><div>&nbsp;</div></div><div><div>    WshExportTaskListTplReq</div></div></li><li><div><div>&nbsp;</div></div><div><div>    WshExportTaskListTplRes</div></div></li><li><div><div>&nbsp;</div></div><div><div>*/</div></div></li><li><div><div>&nbsp;</div></div><div><div>package exporttask</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>import proto \"github.com/golang/protobuf/proto\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>import fmt \"fmt\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>import math \"math\"</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>import (</div></div></li><li><div><div>&nbsp;</div></div><div><div>    context \"golang.org/x/net/context\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    grpc \"google.golang.org/grpc\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>)</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// Reference imports to suppress errors if they are not otherwise used.</div></div></li><li><div><div>&nbsp;</div></div><div><div>var _ = proto.Marshal</div></div></li><li><div><div>&nbsp;</div></div><div><div>var _ = fmt.Errorf</div></div></li><li><div><div>&nbsp;</div></div><div><div>var _ = math.Inf</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// This is a compile-time assertion to ensure that this generated file</div></div></li><li><div><div>&nbsp;</div></div><div><div>// is compatible with the proto package it is being compiled against.</div></div></li><li><div><div>&nbsp;</div></div><div><div>// A compilation error at this line likely means your copy of the</div></div></li><li><div><div>&nbsp;</div></div><div><div>// proto package needs to be updated.</div></div></li><li><div><div>&nbsp;</div></div><div><div>const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// 枚举类型，必须从0开始，序号可跨越。同一包下不能重名，所以加前缀来区别</div></div></li><li><div><div>&nbsp;</div></div><div><div>type WshExportTplStatus int32</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>const (</div></div></li><li><div><div>&nbsp;</div></div><div><div>    WshExportTplStatus_TPL_INITED  WshExportTplStatus = 0</div></div></li><li><div><div>&nbsp;</div></div><div><div>    WshExportTplStatus_TPL_NORMAL  WshExportTplStatus = 1</div></div></li><li><div><div>&nbsp;</div></div><div><div>    WshExportTplStatus_TPL_DELETED WshExportTplStatus = 9</div></div></li><li><div><div>&nbsp;</div></div><div><div>)</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>var WshExportTplStatus_name = map[int32]string{</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0: \"TPL_INITED\",</div></div></li><li><div><div>&nbsp;</div></div><div><div>    1: \"TPL_NORMAL\",</div></div></li><li><div><div>&nbsp;</div></div><div><div>    9: \"TPL_DELETED\",</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div>var WshExportTplStatus_value = map[string]int32{</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"TPL_INITED\":  0,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"TPL_NORMAL\":  1,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"TPL_DELETED\": 9,</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (x WshExportTplStatus) String() string {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return proto.EnumName(WshExportTplStatus_name, int32(x))</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div>func (WshExportTplStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>type WshExportFormat int32</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>const (</div></div></li><li><div><div>&nbsp;</div></div><div><div>    WshExportFormat_FMT_DEFAULT WshExportFormat = 0</div></div></li><li><div><div>&nbsp;</div></div><div><div>    WshExportFormat_FMT_CSV     WshExportFormat = 1</div></div></li><li><div><div>&nbsp;</div></div><div><div>    WshExportFormat_FMT_XLS     WshExportFormat = 2</div></div></li><li><div><div>&nbsp;</div></div><div><div>)</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>var WshExportFormat_name = map[int32]string{</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0: \"FMT_DEFAULT\",</div></div></li><li><div><div>&nbsp;</div></div><div><div>    1: \"FMT_CSV\",</div></div></li><li><div><div>&nbsp;</div></div><div><div>    2: \"FMT_XLS\",</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div>var WshExportFormat_value = map[string]int32{</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"FMT_DEFAULT\": 0,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"FMT_CSV\":     1,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"FMT_XLS\":     2,</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (x WshExportFormat) String() string {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return proto.EnumName(WshExportFormat_name, int32(x))</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div>func (WshExportFormat) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>type WshExportTpl struct {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    EtplName          string          `protobuf:\"bytes,1,opt,name=etplName\" json:\"etplName,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>    EtplTag           string          `protobuf:\"bytes,2,opt,name=etplTag\" json:\"etplTag,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>    EtplOutputFormat  WshExportFormat `protobuf:\"varint,3,opt,name=etplOutputFormat,enum=exporttask.WshExportFormat\" json:\"etplOutputFormat,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>    EtplOutputColumns string          `protobuf:\"bytes,4,opt,name=etplOutputColumns\" json:\"etplOutputColumns,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>    EtplExpr          string          `protobuf:\"bytes,5,opt,name=etplExpr\" json:\"etplExpr,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>    EtplId            int32           `protobuf:\"varint,6,opt,name=etplId\" json:\"etplId,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>    EtplExecTimes     int32           `protobuf:\"varint,7,opt,name=etplExecTimes\" json:\"etplExecTimes,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>    EtplExecOkTimes   int32           `protobuf:\"varint,8,opt,name=etplExecOkTimes\" json:\"etplExecOkTimes,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>    EtplStatus        int32           `protobuf:\"varint,9,opt,name=etplStatus\" json:\"etplStatus,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>    EtplCreated       string          `protobuf:\"bytes,10,opt,name=etplCreated\" json:\"etplCreated,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>    EtplUpdated       string          `protobuf:\"bytes,11,opt,name=etplUpdated\" json:\"etplUpdated,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>    EtplDeleted       string          `protobuf:\"bytes,12,opt,name=etplDeleted\" json:\"etplDeleted,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>    OperatorId        int32           `protobuf:\"varint,13,opt,name=operatorId\" json:\"operatorId,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTpl) Reset()                    { *m = WshExportTpl{} }</div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTpl) String() string            { return proto.CompactTextString(m) }</div></div></li><li><div><div>&nbsp;</div></div><div><div>func (*WshExportTpl) ProtoMessage()               {}</div></div></li><li><div><div>&nbsp;</div></div><div><div>func (*WshExportTpl) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTpl) GetEtplName() string {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.EtplName</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return \"\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTpl) GetEtplTag() string {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.EtplTag</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return \"\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTpl) GetEtplOutputFormat() WshExportFormat {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.EtplOutputFormat</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return WshExportFormat_FMT_DEFAULT</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTpl) GetEtplOutputColumns() string {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.EtplOutputColumns</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return \"\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTpl) GetEtplExpr() string {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.EtplExpr</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return \"\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTpl) GetEtplId() int32 {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.EtplId</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return 0</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTpl) GetEtplExecTimes() int32 {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.EtplExecTimes</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return 0</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTpl) GetEtplExecOkTimes() int32 {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.EtplExecOkTimes</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return 0</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTpl) GetEtplStatus() int32 {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.EtplStatus</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return 0</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTpl) GetEtplCreated() string {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.EtplCreated</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return \"\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTpl) GetEtplUpdated() string {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.EtplUpdated</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return \"\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTpl) GetEtplDeleted() string {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.EtplDeleted</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return \"\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTpl) GetOperatorId() int32 {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.OperatorId</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return 0</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>type WshExportTaskCreateTplReq struct {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    EtplName          string          `protobuf:\"bytes,1,opt,name=etplName\" json:\"etplName,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>    EtplTag           string          `protobuf:\"bytes,2,opt,name=etplTag\" json:\"etplTag,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>    EtplExpr          string          `protobuf:\"bytes,3,opt,name=etplExpr\" json:\"etplExpr,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>    EtplOutputColumns string          `protobuf:\"bytes,4,opt,name=etplOutputColumns\" json:\"etplOutputColumns,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>    EtplOutputFormat  WshExportFormat `protobuf:\"varint,5,opt,name=etplOutputFormat,enum=exporttask.WshExportFormat\" json:\"etplOutputFormat,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>    OperatorId        int32           `protobuf:\"varint,6,opt,name=operatorId\" json:\"operatorId,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTaskCreateTplReq) Reset()                    { *m = WshExportTaskCreateTplReq{} }</div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTaskCreateTplReq) String() string            { return proto.CompactTextString(m) }</div></div></li><li><div><div>&nbsp;</div></div><div><div>func (*WshExportTaskCreateTplReq) ProtoMessage()               {}</div></div></li><li><div><div>&nbsp;</div></div><div><div>func (*WshExportTaskCreateTplReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTaskCreateTplReq) GetEtplName() string {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.EtplName</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return \"\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTaskCreateTplReq) GetEtplTag() string {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.EtplTag</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return \"\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTaskCreateTplReq) GetEtplExpr() string {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.EtplExpr</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return \"\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTaskCreateTplReq) GetEtplOutputColumns() string {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.EtplOutputColumns</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return \"\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTaskCreateTplReq) GetEtplOutputFormat() WshExportFormat {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.EtplOutputFormat</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return WshExportFormat_FMT_DEFAULT</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTaskCreateTplReq) GetOperatorId() int32 {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.OperatorId</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return 0</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>type WshExportTaskCreateTplRes struct {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    ErrCode string        `protobuf:\"bytes,1,opt,name=errCode\" json:\"errCode,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>    ErrMsg  string        `protobuf:\"bytes,2,opt,name=errMsg\" json:\"errMsg,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>    Data    *WshExportTpl `protobuf:\"bytes,3,opt,name=data\" json:\"data,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTaskCreateTplRes) Reset()                    { *m = WshExportTaskCreateTplRes{} }</div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTaskCreateTplRes) String() string            { return proto.CompactTextString(m) }</div></div></li><li><div><div>&nbsp;</div></div><div><div>func (*WshExportTaskCreateTplRes) ProtoMessage()               {}</div></div></li><li><div><div>&nbsp;</div></div><div><div>func (*WshExportTaskCreateTplRes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTaskCreateTplRes) GetErrCode() string {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.ErrCode</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return \"\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTaskCreateTplRes) GetErrMsg() string {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.ErrMsg</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return \"\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTaskCreateTplRes) GetData() *WshExportTpl {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.Data</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return nil</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>type WshExportTaskListTplReq struct {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    EtplId   int32  `protobuf:\"varint,1,opt,name=etplId\" json:\"etplId,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>    EtplName string `protobuf:\"bytes,2,opt,name=etplName\" json:\"etplName,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>    EtplTag  string `protobuf:\"bytes,3,opt,name=etplTag\" json:\"etplTag,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTaskListTplReq) Reset()                    { *m = WshExportTaskListTplReq{} }</div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTaskListTplReq) String() string            { return proto.CompactTextString(m) }</div></div></li><li><div><div>&nbsp;</div></div><div><div>func (*WshExportTaskListTplReq) ProtoMessage()               {}</div></div></li><li><div><div>&nbsp;</div></div><div><div>func (*WshExportTaskListTplReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTaskListTplReq) GetEtplId() int32 {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.EtplId</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return 0</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTaskListTplReq) GetEtplName() string {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.EtplName</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return \"\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTaskListTplReq) GetEtplTag() string {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.EtplTag</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return \"\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// repeated 表示数组</div></div></li><li><div><div>&nbsp;</div></div><div><div>type WshExportTaskListTplRes struct {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    ErrCode string          `protobuf:\"bytes,1,opt,name=errCode\" json:\"errCode,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>    ErrMsg  string          `protobuf:\"bytes,2,opt,name=errMsg\" json:\"errMsg,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>    Data    []*WshExportTpl `protobuf:\"bytes,3,rep,name=data\" json:\"data,omitempty\"`</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTaskListTplRes) Reset()                    { *m = WshExportTaskListTplRes{} }</div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTaskListTplRes) String() string            { return proto.CompactTextString(m) }</div></div></li><li><div><div>&nbsp;</div></div><div><div>func (*WshExportTaskListTplRes) ProtoMessage()               {}</div></div></li><li><div><div>&nbsp;</div></div><div><div>func (*WshExportTaskListTplRes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTaskListTplRes) GetErrCode() string {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.ErrCode</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return \"\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTaskListTplRes) GetErrMsg() string {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.ErrMsg</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return \"\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (m *WshExportTaskListTplRes) GetData() []*WshExportTpl {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if m != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return m.Data</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return nil</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func init() {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    proto.RegisterType((*WshExportTpl)(nil), \"exporttask.WshExportTpl\")</div></div></li><li><div><div>&nbsp;</div></div><div><div>    proto.RegisterType((*WshExportTaskCreateTplReq)(nil), \"exporttask.WshExportTaskCreateTplReq\")</div></div></li><li><div><div>&nbsp;</div></div><div><div>    proto.RegisterType((*WshExportTaskCreateTplRes)(nil), \"exporttask.WshExportTaskCreateTplRes\")</div></div></li><li><div><div>&nbsp;</div></div><div><div>    proto.RegisterType((*WshExportTaskListTplReq)(nil), \"exporttask.WshExportTaskListTplReq\")</div></div></li><li><div><div>&nbsp;</div></div><div><div>    proto.RegisterType((*WshExportTaskListTplRes)(nil), \"exporttask.WshExportTaskListTplRes\")</div></div></li><li><div><div>&nbsp;</div></div><div><div>    proto.RegisterEnum(\"exporttask.WshExportTplStatus\", WshExportTplStatus_name, WshExportTplStatus_value)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    proto.RegisterEnum(\"exporttask.WshExportFormat\", WshExportFormat_name, WshExportFormat_value)</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// Reference imports to suppress errors if they are not otherwise used.</div></div></li><li><div><div>&nbsp;</div></div><div><div>var _ context.Context</div></div></li><li><div><div>&nbsp;</div></div><div><div>var _ grpc.ClientConn</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// This is a compile-time assertion to ensure that this generated file</div></div></li><li><div><div>&nbsp;</div></div><div><div>// is compatible with the grpc package it is being compiled against.</div></div></li><li><div><div>&nbsp;</div></div><div><div>const _ = grpc.SupportPackageIsVersion4</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// Client API for ExportTask service</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>type ExportTaskClient interface {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    // 创建任务模板</div></div></li><li><div><div>&nbsp;</div></div><div><div>    CreateTpl(ctx context.Context, in *WshExportTaskCreateTplReq, opts ...grpc.CallOption) (*WshExportTaskCreateTplRes, error)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    // 查询任务模板</div></div></li><li><div><div>&nbsp;</div></div><div><div>    ListTpl(ctx context.Context, in *WshExportTaskListTplReq, opts ...grpc.CallOption) (*WshExportTaskListTplRes, error)</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>type exportTaskClient struct {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    cc *grpc.ClientConn</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func NewExportTaskClient(cc *grpc.ClientConn) ExportTaskClient {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return &amp;exportTaskClient{cc}</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (c *exportTaskClient) CreateTpl(ctx context.Context, in *WshExportTaskCreateTplReq, opts ...grpc.CallOption) (*WshExportTaskCreateTplRes, error) {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    out := new(WshExportTaskCreateTplRes)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    err := grpc.Invoke(ctx, \"/exporttask.ExportTask/CreateTpl\", in, out, c.cc, opts...)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if err != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return nil, err</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return out, nil</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (c *exportTaskClient) ListTpl(ctx context.Context, in *WshExportTaskListTplReq, opts ...grpc.CallOption) (*WshExportTaskListTplRes, error) {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    out := new(WshExportTaskListTplRes)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    err := grpc.Invoke(ctx, \"/exporttask.ExportTask/ListTpl\", in, out, c.cc, opts...)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if err != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return nil, err</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return out, nil</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// Server API for ExportTask service</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>type ExportTaskServer interface {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    // 创建任务模板</div></div></li><li><div><div>&nbsp;</div></div><div><div>    CreateTpl(context.Context, *WshExportTaskCreateTplReq) (*WshExportTaskCreateTplRes, error)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    // 查询任务模板</div></div></li><li><div><div>&nbsp;</div></div><div><div>    ListTpl(context.Context, *WshExportTaskListTplReq) (*WshExportTaskListTplRes, error)</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func RegisterExportTaskServer(s *grpc.Server, srv ExportTaskServer) {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    s.RegisterService(&amp;_ExportTask_serviceDesc, srv)</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func _ExportTask_CreateTpl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    in := new(WshExportTaskCreateTplReq)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if err := dec(in); err != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return nil, err</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if interceptor == nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return srv.(ExportTaskServer).CreateTpl(ctx, in)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    info := &amp;grpc.UnaryServerInfo{</div></div></li><li><div><div>&nbsp;</div></div><div><div>        Server:     srv,</div></div></li><li><div><div>&nbsp;</div></div><div><div>        FullMethod: \"/exporttask.ExportTask/CreateTpl\",</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    handler := func(ctx context.Context, req interface{}) (interface{}, error) {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return srv.(ExportTaskServer).CreateTpl(ctx, req.(*WshExportTaskCreateTplReq))</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return interceptor(ctx, in, info, handler)</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func _ExportTask_ListTpl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    in := new(WshExportTaskListTplReq)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if err := dec(in); err != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return nil, err</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if interceptor == nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return srv.(ExportTaskServer).ListTpl(ctx, in)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    info := &amp;grpc.UnaryServerInfo{</div></div></li><li><div><div>&nbsp;</div></div><div><div>        Server:     srv,</div></div></li><li><div><div>&nbsp;</div></div><div><div>        FullMethod: \"/exporttask.ExportTask/ListTpl\",</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    handler := func(ctx context.Context, req interface{}) (interface{}, error) {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return srv.(ExportTaskServer).ListTpl(ctx, req.(*WshExportTaskListTplReq))</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return interceptor(ctx, in, info, handler)</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>var _ExportTask_serviceDesc = grpc.ServiceDesc{</div></div></li><li><div><div>&nbsp;</div></div><div><div>    ServiceName: \"exporttask.ExportTask\",</div></div></li><li><div><div>&nbsp;</div></div><div><div>    HandlerType: (*ExportTaskServer)(nil),</div></div></li><li><div><div>&nbsp;</div></div><div><div>    Methods: []grpc.MethodDesc{</div></div></li><li><div><div>&nbsp;</div></div><div><div>        {</div></div></li><li><div><div>&nbsp;</div></div><div><div>            MethodName: \"CreateTpl\",</div></div></li><li><div><div>&nbsp;</div></div><div><div>            Handler:    _ExportTask_CreateTpl_Handler,</div></div></li><li><div><div>&nbsp;</div></div><div><div>        },</div></div></li><li><div><div>&nbsp;</div></div><div><div>        {</div></div></li><li><div><div>&nbsp;</div></div><div><div>            MethodName: \"ListTpl\",</div></div></li><li><div><div>&nbsp;</div></div><div><div>            Handler:    _ExportTask_ListTpl_Handler,</div></div></li><li><div><div>&nbsp;</div></div><div><div>        },</div></div></li><li><div><div>&nbsp;</div></div><div><div>    },</div></div></li><li><div><div>&nbsp;</div></div><div><div>    Streams:  []grpc.StreamDesc{},</div></div></li><li><div><div>&nbsp;</div></div><div><div>    Metadata: \"exporttask.proto\",</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func init() { proto.RegisterFile(\"exporttask.proto\", fileDescriptor0) }</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>var fileDescriptor0 = []byte{</div></div></li><li><div><div>&nbsp;</div></div><div><div>    // 550 bytes of a gzipped FileDescriptorProto</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xa4, 0x54, 0x5f, 0x8f, 0xd2, 0x4e,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0x14, 0xa5, 0xb0, 0xc0, 0x72, 0x59, 0x96, 0xfe, 0xe6, 0xe1, 0xe7, 0x88, 0xc6, 0x90, 0xaa, 0x09,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0xd9, 0x6c, 0x30, 0xc1, 0x57, 0x5f, 0x76, 0xa1, 0x18, 0x92, 0x02, 0x1b, 0x28, 0x6a, 0xe2, 0xc3,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0xa6, 0x6e, 0x47, 0x24, 0x14, 0x5b, 0x67, 0x86, 0xb8, 0xc6, 0x57, 0x3f, 0x98, 0x5f, 0xc6, 0xef,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0x61, 0x66, 0xda, 0x61, 0x5a, 0xfe, 0xc4, 0x75, 0x7d, 0x9b, 0x73, 0xe6, 0x94, 0x7b, 0xef, 0x39,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0x77, 0x00, 0x93, 0xdc, 0x46, 0x21, 0xe5, 0xdc, 0x63, 0xcb, 0x76, 0x44, 0x43, 0x1e, 0x22, 0xd0,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0x8c, 0xf5, 0xab, 0x00, 0x27, 0x6f, 0xd9, 0x27, 0x5b, 0x32, 0x6e, 0x14, 0xa0, 0x06, 0x1c, 0x13,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0x1e, 0x05, 0x23, 0x6f, 0x45, 0xb0, 0xd1, 0x34, 0x5a, 0x95, 0xc9, 0x06, 0x23, 0x0c, 0x65, 0x71,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0x76, 0xbd, 0x39, 0xce, 0xcb, 0x2b, 0x05, 0xd1, 0x6b, 0x30, 0xc5, 0x71, 0xbc, 0xe6, 0xd1, 0x9a,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0xf7, 0x43, 0xba, 0xf2, 0x38, 0x2e, 0x34, 0x8d, 0xd6, 0x69, 0xe7, 0x51, 0x3b, 0x55, 0x7f, 0x53,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0x29, 0x96, 0x4c, 0x76, 0x3e, 0x42, 0xe7, 0xf0, 0x9f, 0xe6, 0xba, 0x61, 0xb0, 0x5e, 0x7d, 0x66,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0xf8, 0x48, 0x16, 0xdb, 0xbd, 0x50, 0xcd, 0xda, 0xb7, 0x11, 0xc5, 0x45, 0xdd, 0xac, 0xc0, 0xe8,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0x7f, 0x28, 0x89, 0xf3, 0xc0, 0xc7, 0xa5, 0xa6, 0xd1, 0x2a, 0x4e, 0x12, 0x84, 0x9e, 0x41, 0x2d,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0xd6, 0x90, 0x1b, 0x77, 0xb1, 0x22, 0x0c, 0x97, 0xe5, 0x75, 0x96, 0x44, 0x2d, 0xa8, 0x2b, 0x62,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0xbc, 0x8c, 0x75, 0xc7, 0x52, 0xb7, 0x4d, 0xa3, 0x27, 0x00, 0x82, 0x9a, 0x72, 0x8f, 0xaf, 0x19,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0xae, 0x48, 0x51, 0x8a, 0x41, 0x4d, 0xa8, 0x0a, 0xd4, 0xa5, 0xc4, 0xe3, 0xc4, 0xc7, 0x20, 0xdb,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0x4c, 0x53, 0x4a, 0x31, 0x8b, 0x7c, 0xa9, 0xa8, 0x6a, 0x45, 0x42, 0x29, 0x45, 0x8f, 0x04, 0x44,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0x28, 0x4e, 0xb4, 0x22, 0xa1, 0x44, 0x17, 0x61, 0x44, 0xa8, 0xc7, 0x43, 0x3a, 0xf0, 0x71, 0x2d,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0xee, 0x42, 0x33, 0xd6, 0x8f, 0x3c, 0x3c, 0xd4, 0x39, 0x7b, 0x6c, 0x19, 0x17, 0x77, 0xa3, 0x60,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0x42, 0xbe, 0xdc, 0x33, 0xf4, 0xb4, 0xfb, 0x85, 0x2d, 0xf7, 0xff, 0x2e, 0xc7, 0x7d, 0xeb, 0x53,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0xbc, 0xcf, 0xfa, 0x64, 0x6d, 0x28, 0xed, 0xd8, 0xf0, 0xfd, 0xb0, 0x0b, 0x4c, 0x4e, 0x4a, 0x69,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0x37, 0xf4, 0x95, 0x09, 0x0a, 0xca, 0x5d, 0xa2, 0x74, 0xc8, 0x94, 0x05, 0x09, 0x42, 0xe7, 0x70,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0xe4, 0x7b, 0xdc, 0x93, 0xd3, 0x57, 0x3b, 0x78, 0x6f, 0xaf, 0xe2, 0xc7, 0xa5, 0xca, 0x9a, 0xc3,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0x83, 0x4c, 0x71, 0x67, 0xc1, 0x78, 0x12, 0x80, 0x5e, 0x56, 0x23, 0xb3, 0xac, 0xe9, 0x60, 0xf2,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0x87, 0x83, 0x29, 0x64, 0x82, 0xb1, 0xbe, 0x1d, 0x2a, 0xf4, 0x6f, 0x33, 0x16, 0xfe, 0x3c, 0xe3,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0x99, 0x0d, 0x28, 0xcd, 0x26, 0x6f, 0xe0, 0x14, 0xc0, 0xbd, 0x72, 0xae, 0x07, 0xa3, 0x81, 0x6b,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0xf7, 0xcc, 0x9c, 0xc2, 0xa3, 0xf1, 0x64, 0x78, 0xe1, 0x98, 0x06, 0xaa, 0x43, 0x55, 0xe0, 0x9e,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0xed, 0xd8, 0x42, 0x50, 0x39, 0x7b, 0x05, 0xf5, 0xad, 0xb0, 0x85, 0xa6, 0x3f, 0x74, 0xaf, 0x7b,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0x76, 0xff, 0x62, 0xe6, 0xb8, 0x66, 0x0e, 0x55, 0xa1, 0x2c, 0x88, 0xee, 0xf4, 0x8d, 0x69, 0x28,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0xf0, 0xce, 0x99, 0x9a, 0xf9, 0xce, 0x4f, 0x03, 0x40, 0x4f, 0x8f, 0xde, 0x43, 0x65, 0x93, 0x33,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0x7a, 0xbe, 0x7f, 0x80, 0xad, 0x17, 0xd1, 0xb8, 0x93, 0x8c, 0x59, 0x39, 0x34, 0x83, 0x72, 0x62,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0x2f, 0x7a, 0x7a, 0xf0, 0x1b, 0x9d, 0x74, 0xe3, 0x0e, 0x22, 0x66, 0xe5, 0x2e, 0x5f, 0xc0, 0xe3,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0x45, 0xd8, 0x9e, 0xd3, 0xe8, 0xa6, 0xfd, 0x95, 0x04, 0x8b, 0x8f, 0x24, 0xab, 0xbd, 0xac, 0x65,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0xe0, 0x95, 0xf1, 0xa1, 0x24, 0xff, 0xdb, 0x5f, 0xfe, 0x0e, 0x00, 0x00, 0xff, 0xff, 0x60, 0x9b,</div></div></li><li><div><div>&nbsp;</div></div><div><div>    0xec, 0x89, 0xef, 0x05, 0x00, 0x00,</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li></ol></code></pre><p>服务端实现proto中的接口：</p><pre><code><ol><li><div><div>&nbsp;</div></div><div><div>package main</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>import (</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"log\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    //\"net\"</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    svcExport \"../../common/exporttask\" // 包含上面的pb生成的go包</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"./model\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    _ \"github.com/go-sql-driver/mysql\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"golang.org/x/net/context\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    //\"google.golang.org/grpc\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    //\"google.golang.org/grpc/reflection\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>)</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// server 这个对象来实现 exporttask 包中的pb定义的rpc服务</div></div></li><li><div><div>&nbsp;</div></div><div><div>// 实现的方式是将服务转化成本地的数据库操作</div></div></li><li><div><div>&nbsp;</div></div><div><div>type server struct{}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (s *server) CreateTpl(ctx context.Context, in *svcExport.WshExportTaskCreateTplReq) (res *svcExport.WshExportTaskCreateTplRes, err error) {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    res = new(svcExport.WshExportTaskCreateTplRes)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    res.Data = new(svcExport.WshExportTpl)</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    var etplId int32 = 0</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    etplId, err = model.CreateTpl(in.EtplName, in.EtplTag, in.EtplExpr, in.EtplOutputColumns, int32(in.EtplOutputFormat), in.OperatorId)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    //res.Data, err = model.GetTpl(etplId)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    res.Data.EtplId = etplId</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return res, err</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func (s *server) ListTpl(ctx context.Context, in *svcExport.WshExportTaskListTplReq) (*svcExport.WshExportTaskListTplRes, error) {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    res := new(svcExport.WshExportTaskListTplRes)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    entList, err := model.ListTpl(in.EtplId, in.EtplName, in.EtplTag)</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    if err != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        res.ErrMsg = err.Error()</div></div></li><li><div><div>&nbsp;</div></div><div><div>        res.ErrCode = \"2\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    for _, ent := range entList {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        t := new(svcExport.WshExportTpl)</div></div></li><li><div><div>&nbsp;</div></div><div><div>        ent.CopyToPb(t)</div></div></li><li><div><div>&nbsp;</div></div><div><div>        res.Data = append(res.Data, t)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    return res, err</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li></ol></code></pre><p>服务端main启动服务main.go</p><pre><code><ol><li><div><div>&nbsp;</div></div><div><div>/**</div></div></li><li><div><div>&nbsp;</div></div><div><div> * exporttask server main</div></div></li><li><div><div>&nbsp;</div></div><div><div> * $ go build exporttask.go</div></div></li><li><div><div>&nbsp;</div></div><div><div> */</div></div></li><li><div><div>&nbsp;</div></div><div><div>package main</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>import (</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"log\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"net\"</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    svcExport \"../../common/exporttask\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    //\"./model\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    _ \"github.com/go-sql-driver/mysql\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    //\"golang.org/x/net/context\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"google.golang.org/grpc\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"google.golang.org/grpc/reflection\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>)</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>const (</div></div></li><li><div><div>&nbsp;</div></div><div><div>    port = \":50051\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>)</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func main() {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    lis, err := net.Listen(\"tcp\", port)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if err != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        log.Fatalf(\"failed to listen: %v\", err)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    // 生成一个rpc服务器</div></div></li><li><div><div>&nbsp;</div></div><div><div>    s := grpc.NewServer()</div></div></li><li><div><div>&nbsp;</div></div><div><div>    // 使用pb包调用注册已实现的rpc接口类server</div></div></li><li><div><div>&nbsp;</div></div><div><div>    svcExport.RegisterExportTaskServer(s, &amp;server{})</div></div></li><li><div><div>&nbsp;</div></div><div><div>    // Register reflection service on gRPC server.</div></div></li><li><div><div>&nbsp;</div></div><div><div>    reflection.Register(s)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if err := s.Serve(lis); err != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        log.Fatalf(\"failed to serve: %v\", err)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li></ol></code></pre><h3><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a>Golang gRPC客户端</h3><p>客户端的代码相对比较简单</p><pre><code><ol><li><div><div>&nbsp;</div></div><div><div>package main</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>import (</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"flag\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"log\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"os\"</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    svcExport \"../../common/exporttask\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"golang.org/x/net/context\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"google.golang.org/grpc\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>)</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>const (</div></div></li><li><div><div>&nbsp;</div></div><div><div>    address     = \"<a target=\"_blank\" rel=\"nofollow\" href=\"https://www.baidu.com/s?wd=127.0.0.1&amp;amp;tn=24004469_oem_dg&amp;amp;rsv_dl=gh_pl_sl_csd\">127.0.0.1</a>:50052\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    defaultName = \"world\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>)</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func main() {</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    // 发起链接</div></div></li><li><div><div>&nbsp;</div></div><div><div>    conn, err := grpc.Dial(address, grpc.WithInsecure())</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if err != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        log.Fatalf(\"did not connect: %v\", err)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    defer conn.Close()</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    // 创建pb包的客户端</div></div></li><li><div><div>&nbsp;</div></div><div><div>    c := svcExport.NewExportTaskClient(conn)</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    name := defaultName</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if len(os.Args) &gt; 1 {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        name = os.Args[1]</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    // 发起请求</div></div></li><li><div><div>&nbsp;</div></div><div><div>    var r2 *svcExport.WshExportTaskCreateTplRes</div></div></li><li><div><div>&nbsp;</div></div><div><div>    req := svcExport.WshExportTaskCreateTplReq{EtplName: name, EtplTag: \"mall\", EtplExpr: \"select EtplName from welife_export_tpl\", EtplOutputFormat: svcExport.WshExportFormat_FMT_CSV, EtplOutputColumns: \"\"}</div></div></li><li><div><div>&nbsp;</div></div><div><div>    r2, err = c.CreateTpl(context.Background(), &amp;req)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    // 打印结果</div></div></li><li><div><div>&nbsp;</div></div><div><div>    log.Println(\"create tpl: r=\", r2, err)</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li></ol></code></pre><h2><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a>php中使用gRPC</h2><p>php需要安装grpc扩展。 <br>使用protoc命令生成对应的php代码：</p><pre><code>protoc --php_out=plugins=grpc:./ exporttask.proto</code></pre><ul><li>1</li><li>2</li></ul><p>生成代码包括：</p><pre><code><ol><li><div><div>&nbsp;</div></div><div><div>Exporttask/</div></div></li><li><div><div>&nbsp;</div></div><div><div>  |-WshExportFormat.php</div></div></li><li><div><div>&nbsp;</div></div><div><div>  |-WshExportTaskCreateTplReq.php</div></div></li><li><div><div>&nbsp;</div></div><div><div>  |-WshExportTaskCreateTplRes.php</div></div></li><li><div><div>&nbsp;</div></div><div><div>  |-WshExportTaskListTplReq.php</div></div></li><li><div><div>&nbsp;</div></div><div><div>  |-WshExportTaskListTplRes.php</div></div></li><li><div><div>&nbsp;</div></div><div><div>  |-WshExportTpl.php</div></div></li><li><div><div>&nbsp;</div></div><div><div>  \\-WshExportTplStatus.php</div></div></li><li><div><div>&nbsp;</div></div><div><div>GPBMetadata/</div></div></li><li><div><div>&nbsp;</div></div><div><div>  \\-Exporttask.php</div></div></li></ol></code></pre><p>每一个message对应生成一个类，在Exporttask命名空间下。 <br>这里就不都贴出来了，只贴一个WshExportTpl.php：</p><pre><code><ol><li><div><div>&nbsp;</div></div><div><div>&lt;?php</div></div></li><li><div><div>&nbsp;</div></div><div><div># Generated by the protocol buffer compiler.  DO NOT EDIT!</div></div></li><li><div><div>&nbsp;</div></div><div><div># source: exporttask.proto</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>namespace Exporttask;</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>use Google\\Protobuf\\Internal\\GPBType;</div></div></li><li><div><div>&nbsp;</div></div><div><div>use Google\\Protobuf\\Internal\\RepeatedField;</div></div></li><li><div><div>&nbsp;</div></div><div><div>use Google\\Protobuf\\Internal\\GPBUtil;</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>/**</div></div></li><li><div><div>&nbsp;</div></div><div><div> * Protobuf type &lt;code&gt;exporttask.WshExportTpl&lt;/code&gt;</div></div></li><li><div><div>&nbsp;</div></div><div><div> */</div></div></li><li><div><div>&nbsp;</div></div><div><div>class WshExportTpl extends \\Google\\Protobuf\\Internal\\Message</div></div></li><li><div><div>&nbsp;</div></div><div><div>{</div></div></li><li><div><div>&nbsp;</div></div><div><div>    /**</div></div></li><li><div><div>&nbsp;</div></div><div><div>     * &lt;code&gt;string etplName = 1;&lt;/code&gt;</div></div></li><li><div><div>&nbsp;</div></div><div><div>     */</div></div></li><li><div><div>&nbsp;</div></div><div><div>    private $etplName = \'\';</div></div></li><li><div><div>&nbsp;</div></div><div><div>    /**</div></div></li><li><div><div>&nbsp;</div></div><div><div>     * &lt;code&gt;string etplTag = 2;&lt;/code&gt;</div></div></li><li><div><div>&nbsp;</div></div><div><div>     */</div></div></li><li><div><div>&nbsp;</div></div><div><div>    private $etplTag = \'\';</div></div></li><li><div><div>&nbsp;</div></div><div><div>    /**</div></div></li><li><div><div>&nbsp;</div></div><div><div>     * &lt;code&gt;.exporttask.WshExportFormat etplOutputFormat = 3;&lt;/code&gt;</div></div></li><li><div><div>&nbsp;</div></div><div><div>     */</div></div></li><li><div><div>&nbsp;</div></div><div><div>    private $etplOutputFormat = 0;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    /**</div></div></li><li><div><div>&nbsp;</div></div><div><div>     * &lt;code&gt;string etplOutputColumns = 4;&lt;/code&gt;</div></div></li><li><div><div>&nbsp;</div></div><div><div>     */</div></div></li><li><div><div>&nbsp;</div></div><div><div>    private $etplOutputColumns = \'\';</div></div></li><li><div><div>&nbsp;</div></div><div><div>    /**</div></div></li><li><div><div>&nbsp;</div></div><div><div>     * &lt;code&gt;string etplExpr = 5;&lt;/code&gt;</div></div></li><li><div><div>&nbsp;</div></div><div><div>     */</div></div></li><li><div><div>&nbsp;</div></div><div><div>    private $etplExpr = \'\';</div></div></li><li><div><div>&nbsp;</div></div><div><div>    /**</div></div></li><li><div><div>&nbsp;</div></div><div><div>     * &lt;code&gt;int32 etplId = 6;&lt;/code&gt;</div></div></li><li><div><div>&nbsp;</div></div><div><div>     */</div></div></li><li><div><div>&nbsp;</div></div><div><div>    private $etplId = 0;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    /**</div></div></li><li><div><div>&nbsp;</div></div><div><div>     * &lt;code&gt;int32 etplExecTimes = 7;&lt;/code&gt;</div></div></li><li><div><div>&nbsp;</div></div><div><div>     */</div></div></li><li><div><div>&nbsp;</div></div><div><div>    private $etplExecTimes = 0;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    /**</div></div></li><li><div><div>&nbsp;</div></div><div><div>     * &lt;code&gt;int32 etplExecOkTimes = 8;&lt;/code&gt;</div></div></li><li><div><div>&nbsp;</div></div><div><div>     */</div></div></li><li><div><div>&nbsp;</div></div><div><div>    private $etplExecOkTimes = 0;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    /**</div></div></li><li><div><div>&nbsp;</div></div><div><div>     * &lt;code&gt;int32 etplStatus = 9;&lt;/code&gt;</div></div></li><li><div><div>&nbsp;</div></div><div><div>     */</div></div></li><li><div><div>&nbsp;</div></div><div><div>    private $etplStatus = 0;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    /**</div></div></li><li><div><div>&nbsp;</div></div><div><div>     * &lt;code&gt;string etplCreated = 10;&lt;/code&gt;</div></div></li><li><div><div>&nbsp;</div></div><div><div>     */</div></div></li><li><div><div>&nbsp;</div></div><div><div>    private $etplCreated = \'\';</div></div></li><li><div><div>&nbsp;</div></div><div><div>    /**</div></div></li><li><div><div>&nbsp;</div></div><div><div>     * &lt;code&gt;string etplUpdated = 11;&lt;/code&gt;</div></div></li><li><div><div>&nbsp;</div></div><div><div>     */</div></div></li><li><div><div>&nbsp;</div></div><div><div>    private $etplUpdated = \'\';</div></div></li><li><div><div>&nbsp;</div></div><div><div>    /**</div></div></li><li><div><div>&nbsp;</div></div><div><div>     * &lt;code&gt;string etplDeleted = 12;&lt;/code&gt;</div></div></li><li><div><div>&nbsp;</div></div><div><div>     */</div></div></li><li><div><div>&nbsp;</div></div><div><div>    private $etplDeleted = \'\';</div></div></li><li><div><div>&nbsp;</div></div><div><div>    /**</div></div></li><li><div><div>&nbsp;</div></div><div><div>     * &lt;code&gt;int32 operatorId = 13;&lt;/code&gt;</div></div></li><li><div><div>&nbsp;</div></div><div><div>     */</div></div></li><li><div><div>&nbsp;</div></div><div><div>    private $operatorId = 0;</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    public function __construct() {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        \\GPBMetadata\\Exporttask::initOnce();</div></div></li><li><div><div>&nbsp;</div></div><div><div>        parent::__construct();</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    /**</div></div></li><li><div><div>&nbsp;</div></div><div><div>     * &lt;code&gt;string etplName = 1;&lt;/code&gt;</div></div></li><li><div><div>&nbsp;</div></div><div><div>     */</div></div></li><li><div><div>&nbsp;</div></div><div><div>    public function getEtplName()</div></div></li><li><div><div>&nbsp;</div></div><div><div>    {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return $this-&gt;etplName;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    /**</div></div></li><li><div><div>&nbsp;</div></div><div><div>     * &lt;code&gt;string etplName = 1;&lt;/code&gt;</div></div></li><li><div><div>&nbsp;</div></div><div><div>     */</div></div></li><li><div><div>&nbsp;</div></div><div><div>    public function setEtplName($var)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        GPBUtil::checkString($var, True);</div></div></li><li><div><div>&nbsp;</div></div><div><div>        $this-&gt;etplName = $var;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    // ... 其他省略</div></div></li></ol></code></pre><pre><code><ol><li><div><div>&nbsp;</div></div><div><div>&lt;?php</div></div></li><li><div><div>&nbsp;</div></div><div><div>  $client = new \\Exporttask\\GreeterClient(\'127.0.0.1:50051\', [</div></div></li><li><div><div>&nbsp;</div></div><div><div>        \'credentials\' =&gt; \\Grpc\\ChannelCredentials::createInsecure(),</div></div></li><li><div><div>&nbsp;</div></div><div><div>    ]);</div></div></li><li><div><div>&nbsp;</div></div><div><div>  $request = new Exporttask\\WshExportTaskCreateTplReq();</div></div></li><li><div><div>&nbsp;</div></div><div><div>  $request-&gt;setEtplName($name);</div></div></li><li><div><div>&nbsp;</div></div><div><div>  list($reply, $status) = $client-&gt;createTpl($request)-&gt;wait();</div></div></li><li><div><div>&nbsp;</div></div><div><div>  $message = $reply-&gt;getMessage();</div></div></li><li><div><div>&nbsp;</div></div><div><div>  var_dump($message);</div></div></li></ol></code></pre><h2><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a>gRPC服务发现与服务治理的方案</h2><p>目前gRPC主流分布式方案有这么几种： etcd, zookeeper, consul.</p><h3><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a>1、集中式LB（Proxy Model）</h3><p><img alt=\"LB\">&nbsp;<br>在服务消费者和服务提供者之间有一个独立的LB，通常是专门的硬件设备如 F5，或者基于软件如 LVS，HAproxy等实现。LB上有所有服务的地址映射表，通常由运维配置注册，当服务消费方调用某个目标服务时，它向LB发起请求，由LB以某种策略，比如轮询（Round-Robin）做负载均衡后将请求转发到目标服务。LB一般具备健康检查能力，能自动摘除不健康的服务实例。 该方案主要问题：</p><ul><li>1、 单点问题，所有服务调用流量都经过LB，当服务数量和调用量大的时候，LB容易成为瓶颈，且一旦LB发生故障影响整个系统；</li><li>2、服务消费方、提供方之间增加了一级，有一定性能开销。</li></ul><h3><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a>2、进程内LB（Balancing-aware Client）</h3><p><img alt=\"\">&nbsp;<br>针对第一个方案的不足，此方案将LB的功能集成到服务消费方进程里，也被称为软负载或者客户端负载方案。服务提供方启动时，首先将服务地址注册到服务注册表，同时定期报心跳到服务注册表以表明服务的存活状态，相当于健康检查，服务消费方要访问某个服务时，它通过内置的LB组件向服务注册表查询，同时缓存并定期刷新目标服务地址列表，然后以某种负载均衡策略选择一个目标服务地址，最后向目标服务发起请求。LB和服务发现能力被分散到每一个服务消费者的进程内部，同时服务消费方和服务提供方之间是直接调用，没有额外开销，性能比较好。该方案主要问题：</p><ul><li>1、开发成本，该方案将服务调用方集成到客户端的进程里头，如果有多种不同的语言栈，就要配合开发多种不同的客户端，有一定的研发和维护成本；</li><li>2、另外生产环境中，后续如果要对客户库进行升级，势必要求服务调用方修改代码并重新发布，升级较复杂。</li></ul><h3><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a>3、独立 LB 进程（External Load Balancing Service）</h3><p><img alt=\"\" src=\"https://img-blog.csdn.net/20171018223331430?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHVkdW9ydWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\">&nbsp;<br>该方案是针对第二种方案的不足而提出的一种折中方案，原理和第二种方案基本类似。<br>不同之处是将LB和服务发现功能从进程内移出来，变成主机上的一个独立进程。主机上的一个或者多个服务要访问目标服务时，他们都通过同一主机上的独立LB进程做服务发现和负载均衡。该方案也是一种分布式方案没有单点问题，一个LB进程挂了只影响该主机上的服务调用方，服务调用方和LB之间是进程内调用性能好，同时该方案还简化了服务调用方，不需要为不同语言开发客户库，LB的升级不需要服务调用方改代码。<br>该方案主要问题：部署较复杂，环节多，出错调试排查问题不方便。</p><h2><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a><a target=\"_blank\" rel=\"nofollow\">&nbsp;</a>服务发现负载均衡实现</h2><p>gRPC开源组件官方并未直接提供服务注册与发现的功能实现，但其设计文档已提供实现的思路，并在不同语言的gRPC代码API中已提供了命名解析和负载均衡接口供扩展。 <br><img alt=\"\" src=\"https://img-blog.csdn.net/20171018223506116?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveHVkdW9ydWk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\"></p><p>其基本实现原理：</p><ul><li>1、服务启动后gRPC客户端向命名服务器发出名称解析请求，名称将解析为一个或多个IP地址，每个IP地址标示它是服务器地址还是负载均衡器地址，以及标示要使用那个客户端负载均衡策略或服务配置。</li><li>2、客户端实例化负载均衡策略，如果解析返回的地址是负载均衡器地址，则客户端将使用grpclb策略，否则客户端使用服务配置请求的负载均衡策略。</li><li>3、负载均衡策略为每个服务器地址创建一个子通道（channel）。</li><li>4、当有rpc请求时，负载均衡策略决定那个子通道即grpc服务器将接收请求，当可用服务器为空时客户端的请求将被阻塞。</li></ul><p>根据gRPC官方提供的设计思路，基于进程内LB方案（即第2个案，阿里开源的服务框架 Dubbo 也是采用类似机制），结合分布式一致的组件（如Zookeeper、Consul、Etcd），可找到gRPC服务发现和负载均衡的可行解决方案。接下来以GO语言为例，简单介绍下基于Etcd3的关键代码实现：</p><p>1）命名解析实现：resolver.go</p><pre><code><ol><li><div><div>&nbsp;</div></div><div><div>package etcdv3</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>import (</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"errors\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"fmt\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"strings\"</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    etcd3 \"github.com/coreos/etcd/clientv3\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"google.golang.org/grpc/naming\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>)</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// resolver is the implementaion of grpc.naming.Resolver</div></div></li><li><div><div>&nbsp;</div></div><div><div>type resolver struct {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    serviceName string // service name to resolve</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// NewResolver return resolver with service name</div></div></li><li><div><div>&nbsp;</div></div><div><div>func NewResolver(serviceName string) *resolver {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return &amp;resolver{serviceName: serviceName}</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// Resolve to resolve the service from etcd, target is the dial address of etcd</div></div></li><li><div><div>&nbsp;</div></div><div><div>// target example: \"http://127.0.0.1:2379,http://127.0.0.1:12379,http://127.0.0.1:22379\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>func (re *resolver) Resolve(target string) (naming.Watcher, error) {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if re.serviceName == \"\" {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return nil, errors.New(\"grpclb: no service name provided\")</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    // generate etcd client</div></div></li><li><div><div>&nbsp;</div></div><div><div>    client, err := etcd3.New(etcd3.Config{</div></div></li><li><div><div>&nbsp;</div></div><div><div>        Endpoints: strings.Split(target, \",\"),</div></div></li><li><div><div>&nbsp;</div></div><div><div>    })</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if err != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return nil, fmt.Errorf(\"grpclb: creat etcd3 client failed: %s\", err.Error())</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    // Return watcher</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return &amp;watcher{re: re, client: *client}, nil</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li></ol></code></pre><p>2）服务发现实现：watcher.go</p><pre><code><ol><li><div><div>&nbsp;</div></div><div><div>package etcdv3</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>import (</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"fmt\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    etcd3 \"github.com/coreos/etcd/clientv3\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"golang.org/x/net/context\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"google.golang.org/grpc/naming\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"github.com/coreos/etcd/mvcc/mvccpb\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>)</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// watcher is the implementaion of grpc.naming.Watcher</div></div></li><li><div><div>&nbsp;</div></div><div><div>type watcher struct {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    re            *resolver // re: Etcd Resolver</div></div></li><li><div><div>&nbsp;</div></div><div><div>    client        etcd3.Client</div></div></li><li><div><div>&nbsp;</div></div><div><div>    isInitialized bool</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// Close do nothing</div></div></li><li><div><div>&nbsp;</div></div><div><div>func (w *watcher) Close() {</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// Next to return the updates</div></div></li><li><div><div>&nbsp;</div></div><div><div>func (w *watcher) Next() ([]*naming.Update, error) {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    // prefix is the etcd prefix/value to watch</div></div></li><li><div><div>&nbsp;</div></div><div><div>    prefix := fmt.Sprintf(\"/%s/%s/\", Prefix, w.re.serviceName)</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    // check if is initialized</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if !w.isInitialized {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        // query addresses from etcd</div></div></li><li><div><div>&nbsp;</div></div><div><div>        resp, err := w.client.Get(context.Background(), prefix, etcd3.WithPrefix())</div></div></li><li><div><div>&nbsp;</div></div><div><div>        w.isInitialized = true</div></div></li><li><div><div>&nbsp;</div></div><div><div>        if err == nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>            addrs := extractAddrs(resp)</div></div></li><li><div><div>&nbsp;</div></div><div><div>            //if not empty, return the updates or watcher new dir</div></div></li><li><div><div>&nbsp;</div></div><div><div>            if l := len(addrs); l != 0 {</div></div></li><li><div><div>&nbsp;</div></div><div><div>                updates := make([]*naming.Update, l)</div></div></li><li><div><div>&nbsp;</div></div><div><div>                for i := range addrs {</div></div></li><li><div><div>&nbsp;</div></div><div><div>                    updates[i] = &amp;naming.Update{Op: naming.Add, Addr: addrs[i]}</div></div></li><li><div><div>&nbsp;</div></div><div><div>                }</div></div></li><li><div><div>&nbsp;</div></div><div><div>                return updates, nil</div></div></li><li><div><div>&nbsp;</div></div><div><div>            }</div></div></li><li><div><div>&nbsp;</div></div><div><div>        }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    // generate etcd Watcher</div></div></li><li><div><div>&nbsp;</div></div><div><div>    rch := w.client.Watch(context.Background(), prefix, etcd3.WithPrefix())</div></div></li><li><div><div>&nbsp;</div></div><div><div>    for wresp := range rch {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        for _, ev := range wresp.Events {</div></div></li><li><div><div>&nbsp;</div></div><div><div>            switch ev.Type {</div></div></li><li><div><div>&nbsp;</div></div><div><div>            case mvccpb.PUT:</div></div></li><li><div><div>&nbsp;</div></div><div><div>                return []*naming.Update{{Op: naming.Add, Addr: string(ev.Kv.Value)}}, nil</div></div></li><li><div><div>&nbsp;</div></div><div><div>            case mvccpb.DELETE:</div></div></li><li><div><div>&nbsp;</div></div><div><div>                return []*naming.Update{{Op: naming.Delete, Addr: string(ev.Kv.Value)}}, nil</div></div></li><li><div><div>&nbsp;</div></div><div><div>            }</div></div></li><li><div><div>&nbsp;</div></div><div><div>        }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return nil, nil</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func extractAddrs(resp *etcd3.GetResponse) []string {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    addrs := []string{}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    if resp == nil || resp.Kvs == nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return addrs</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    for i := range resp.Kvs {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        if v := resp.Kvs[i].Value; v != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>            addrs = append(addrs, string(v))</div></div></li><li><div><div>&nbsp;</div></div><div><div>        }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    return addrs</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li></ol></code></pre><p>3）服务注册实现：register.go</p><pre><code><ol><li><div><div>&nbsp;</div></div><div><div>package etcdv3</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>import (</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"fmt\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"log\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"strings\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"time\"</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    etcd3 \"github.com/coreos/etcd/clientv3\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"golang.org/x/net/context\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"github.com/coreos/etcd/etcdserver/api/v3rpc/rpctypes\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>)</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// Prefix should start and end with no slash</div></div></li><li><div><div>&nbsp;</div></div><div><div>var Prefix = \"etcd3_naming\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>var client etcd3.Client</div></div></li><li><div><div>&nbsp;</div></div><div><div>var serviceKey string</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>var stopSignal = make(chan bool, 1)</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// Register</div></div></li><li><div><div>&nbsp;</div></div><div><div>func Register(name string, host string, port int, target string, interval time.Duration, ttl int) error {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    serviceValue := fmt.Sprintf(\"%s:%d\", host, port)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    serviceKey = fmt.Sprintf(\"/%s/%s/%s\", Prefix, name, serviceValue)</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    // get endpoints for register dial address</div></div></li><li><div><div>&nbsp;</div></div><div><div>    var err error</div></div></li><li><div><div>&nbsp;</div></div><div><div>    client, err := etcd3.New(etcd3.Config{</div></div></li><li><div><div>&nbsp;</div></div><div><div>        Endpoints: strings.Split(target, \",\"),</div></div></li><li><div><div>&nbsp;</div></div><div><div>    })</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if err != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        return fmt.Errorf(\"grpclb: create etcd3 client failed: %v\", err)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    go func() {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        // invoke self-register with ticker</div></div></li><li><div><div>&nbsp;</div></div><div><div>        ticker := time.NewTicker(interval)</div></div></li><li><div><div>&nbsp;</div></div><div><div>        for {</div></div></li><li><div><div>&nbsp;</div></div><div><div>            // minimum lease TTL is ttl-second</div></div></li><li><div><div>&nbsp;</div></div><div><div>            resp, _ := client.Grant(context.TODO(), int64(ttl))</div></div></li><li><div><div>&nbsp;</div></div><div><div>            // should get first, if not exist, set it</div></div></li><li><div><div>&nbsp;</div></div><div><div>            _, err := client.Get(context.Background(), serviceKey)</div></div></li><li><div><div>&nbsp;</div></div><div><div>            if err != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>                if err == rpctypes.ErrKeyNotFound {</div></div></li><li><div><div>&nbsp;</div></div><div><div>                    if _, err := client.Put(context.TODO(), serviceKey, serviceValue, etcd3.WithLease(resp.ID)); err != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>                        log.Printf(\"grpclb: set service \'%s\' with ttl to etcd3 failed: %s\", name, err.Error())</div></div></li><li><div><div>&nbsp;</div></div><div><div>                    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>                } else {</div></div></li><li><div><div>&nbsp;</div></div><div><div>                    log.Printf(\"grpclb: service \'%s\' connect to etcd3 failed: %s\", name, err.Error())</div></div></li><li><div><div>&nbsp;</div></div><div><div>                }</div></div></li><li><div><div>&nbsp;</div></div><div><div>            } else {</div></div></li><li><div><div>&nbsp;</div></div><div><div>                // refresh set to true for not notifying the watcher</div></div></li><li><div><div>&nbsp;</div></div><div><div>                if _, err := client.Put(context.Background(), serviceKey, serviceValue, etcd3.WithLease(resp.ID)); err != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>                    log.Printf(\"grpclb: refresh service \'%s\' with ttl to etcd3 failed: %s\", name, err.Error())</div></div></li><li><div><div>&nbsp;</div></div><div><div>                }</div></div></li><li><div><div>&nbsp;</div></div><div><div>            }</div></div></li><li><div><div>&nbsp;</div></div><div><div>            select {</div></div></li><li><div><div>&nbsp;</div></div><div><div>            case &lt;-stopSignal:</div></div></li><li><div><div>&nbsp;</div></div><div><div>                return</div></div></li><li><div><div>&nbsp;</div></div><div><div>            case &lt;-ticker.C:</div></div></li><li><div><div>&nbsp;</div></div><div><div>            }</div></div></li><li><div><div>&nbsp;</div></div><div><div>        }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }()</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    return nil</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// UnRegister delete registered service from etcd</div></div></li><li><div><div>&nbsp;</div></div><div><div>func UnRegister() error {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    stopSignal &lt;- true</div></div></li><li><div><div>&nbsp;</div></div><div><div>    stopSignal = make(chan bool, 1) // just a hack to avoid multi UnRegister deadlock</div></div></li><li><div><div>&nbsp;</div></div><div><div>    var err error;</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if _, err := client.Delete(context.Background(), serviceKey); err != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        log.Printf(\"grpclb: deregister \'%s\' failed: %s\", serviceKey, err.Error())</div></div></li><li><div><div>&nbsp;</div></div><div><div>    } else {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        log.Printf(\"grpclb: deregister \'%s\' ok.\", serviceKey)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return err</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li></ol></code></pre><p>4）接口描述文件：helloworld.proto</p><pre><code><ol><li><div><div>&nbsp;</div></div><div><div>syntax = \"proto3\";</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>option java_multiple_files = true;</div></div></li><li><div><div>&nbsp;</div></div><div><div>option java_package = \"com.midea.jr.test.grpc\";</div></div></li><li><div><div>&nbsp;</div></div><div><div>option java_outer_classname = \"HelloWorldProto\";</div></div></li><li><div><div>&nbsp;</div></div><div><div>option objc_class_prefix = \"HLW\";</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>package helloworld;</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// The greeting service definition.</div></div></li><li><div><div>&nbsp;</div></div><div><div>service Greeter {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    //   Sends a greeting</div></div></li><li><div><div>&nbsp;</div></div><div><div>    rpc SayHello (HelloRequest) returns (HelloReply) {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// The request message containing the user\'s name.</div></div></li><li><div><div>&nbsp;</div></div><div><div>message HelloRequest {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    string name = 1;</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// The response message containing the greetings</div></div></li><li><div><div>&nbsp;</div></div><div><div>message HelloReply {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    string message = 1;</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li></ol></code></pre><p>5）实现服务端接口：helloworldserver.go</p><pre><code><ol><li><div><div>&nbsp;</div></div><div><div>package main</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>import (</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"flag\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"fmt\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"log\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"net\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"os\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"os/signal\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"syscall\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"time\"</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"golang.org/x/net/context\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"google.golang.org/grpc\"</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    grpclb \"com.midea/jr/grpclb/naming/etcd/v3\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"com.midea/jr/grpclb/example/pb\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>)</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>var (</div></div></li><li><div><div>&nbsp;</div></div><div><div>    serv = flag.String(\"service\", \"hello_service\", \"service name\")</div></div></li><li><div><div>&nbsp;</div></div><div><div>    port = flag.Int(\"port\", 50001, \"listening port\")</div></div></li><li><div><div>&nbsp;</div></div><div><div>    reg = flag.String(\"reg\", \"http://127.0.0.1:2379\", \"register etcd address\")</div></div></li><li><div><div>&nbsp;</div></div><div><div>)</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func main() {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    flag.Parse()</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    lis, err := net.Listen(\"tcp\", fmt.Sprintf(\"0.0.0.0:%d\", *port))</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if err != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        panic(err)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    err = grpclb.Register(*serv, \"127.0.0.1\", *port, *reg, time.Second*10, 15)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if err != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        panic(err)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    ch := make(chan os.Signal, 1)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    signal.Notify(ch, syscall.SIGTERM, syscall.SIGINT, syscall.SIGKILL, syscall.SIGHUP, syscall.SIGQUIT)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    go func() {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        s := &lt;-ch</div></div></li><li><div><div>&nbsp;</div></div><div><div>        log.Printf(\"receive signal \'%v\'\", s)</div></div></li><li><div><div>&nbsp;</div></div><div><div>        grpclb.UnRegister()</div></div></li><li><div><div>&nbsp;</div></div><div><div>        os.Exit(1)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }()</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    log.Printf(\"starting hello service at %d\", *port)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    s := grpc.NewServer()</div></div></li><li><div><div>&nbsp;</div></div><div><div>    pb.RegisterGreeterServer(s, &amp;server{})</div></div></li><li><div><div>&nbsp;</div></div><div><div>    s.Serve(lis)</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// server is used to implement helloworld.GreeterServer.</div></div></li><li><div><div>&nbsp;</div></div><div><div>type server struct{}</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>// SayHello implements helloworld.GreeterServer</div></div></li><li><div><div>&nbsp;</div></div><div><div>func (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    fmt.Printf(\"%v: Receive is %s\\n\", time.Now(), in.Name)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    return &amp;pb.HelloReply{Message: \"Hello \" + in.Name}, nil</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li></ol></code></pre><p>6）实现客户端接口：helloworldclient.go</p><pre><code><ol><li><div><div>&nbsp;</div></div><div><div>package main</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>import (</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"flag\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"fmt\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"time\"</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    grpclb \"com.midea/jr/grpclb/naming/etcd/v3\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"com.midea/jr/grpclb/example/pb\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"golang.org/x/net/context\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"google.golang.org/grpc\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>    \"strconv\"</div></div></li><li><div><div>&nbsp;</div></div><div><div>)</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>var (</div></div></li><li><div><div>&nbsp;</div></div><div><div>    serv = flag.String(\"service\", \"hello_service\", \"service name\")</div></div></li><li><div><div>&nbsp;</div></div><div><div>    reg = flag.String(\"reg\", \"http://127.0.0.1:2379\", \"register etcd address\")</div></div></li><li><div><div>&nbsp;</div></div><div><div>)</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>func main() {</div></div></li><li><div><div>&nbsp;</div></div><div><div>    flag.Parse()</div></div></li><li><div><div>&nbsp;</div></div><div><div>    r := grpclb.NewResolver(*serv)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    b := grpc.RoundRobin(r)</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    ctx, _ := context.WithTimeout(context.Background(), 10*time.Second)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    conn, err := grpc.DialContext(ctx, *reg, grpc.WithInsecure(), grpc.WithBalancer(b))</div></div></li><li><div><div>&nbsp;</div></div><div><div>    if err != nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        panic(err)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div> </div></div></li><li><div><div>&nbsp;</div></div><div><div>    ticker := time.NewTicker(1 * time.Second)</div></div></li><li><div><div>&nbsp;</div></div><div><div>    for t := range ticker.C {</div></div></li><li><div><div>&nbsp;</div></div><div><div>        client := pb.NewGreeterClient(conn)</div></div></li><li><div><div>&nbsp;</div></div><div><div>        resp, err := client.SayHello(context.Background(), &amp;pb.HelloRequest{Name: \"world \" + strconv.Itoa(t.Second())})</div></div></li><li><div><div>&nbsp;</div></div><div><div>        if err == nil {</div></div></li><li><div><div>&nbsp;</div></div><div><div>            fmt.Printf(\"%v: Reply is %s\\n\", t, resp.Message)</div></div></li><li><div><div>&nbsp;</div></div><div><div>        }</div></div></li><li><div><div>&nbsp;</div></div><div><div>    }</div></div></li><li><div><div>&nbsp;</div></div><div><div>}</div></div></li></ol></code></pre>\n\n<br><p></p>','0','2019-05-16 14:39:03','2019-05-16 14:39:03'), ('11','网站接入代码高亮','','','### highlight.js\n使用bower安装的起了一半作用，有背景色，具体代码没有高亮，手动下载的可以','1','2019-02-20 12:19:06','2019-02-20 12:19:07'), ('13','go如何进行交叉编译','','','# golang交叉编译\n## 问题\ngolang如何在一个平台编译另外一个平台可以执行的文件。比如在mac上编译Windows和linux可以执行的文件。那么我们的问题就设定成：如何在mac上编译64位linux的可执行文件。\n### 解决方案\ngolang的交叉编译要保证golang版本在1.5以上，本解决方案实例代码1.9版本执行的。\n我们想要编译的文件hello.go\nhello.go\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Printf(\"hello, world\\n\")\n}\n```\n在mac上编译64位linux的命令编译命令\nbash:\n```shell\nGOOS=linux GOARCH=amd64 go build hello.go\n```\n上面这段代码直接在命令控制台里面运行就可以生成64位linux的可执行程序。\n参数解析\n这里用到了两个变量：\n\nGOOS：目标操作系统\nGOARCH：目标操作系统的架构\n\nOS|ARCH|OS version\n--|----|---------\nlinux|386 / amd64 / arm|>= Linux 2.6\ndarwin|386 / amd64|OS X (Snow Leopard + Lion)\nfreebsd|386 / amd64|>= FreeBSD 7\nwindows|386 / amd64|>= Windows 2000\n\n编译其他平台的时候根据上面表格参数执行编译就可以了。\n扩展阅读\n在网络上的诸多教程中可能会看到下面的编译命令\n```shell\nCGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build hello.go\n```\n其中CGO_ENABLED=0的意思是使用C语言版本的GO编译器，参数配置为0的时候就关闭C语言版本的编译器了。自从golang1.5以后go就使用go语言编译器进行编译了。在golang1.9当中没有使用CGO_ENABLED参数发现依然可以正常编译。当然使用了也可以正常编译。比如把CGO_ENABLED参数设置成1，即在编译的过程当中使用CGO编译器，我发现依然是可以正常编译的。\n实际上如果在go当中使用了C的库，比如import \"C\"默认使用go build的时候就会启动CGO编译器，当然我们可以使用CGO_ENABLED=0来控制go build是否使用CGO编译器。\n以上若有错误欢迎指正。\n\n作者：ppmoon\n链接：https://www.jianshu.com/p/4b345a9e768e\n來源：简书\n简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。','1','2019-02-20 10:07:34','2019-02-20 10:07:34'), ('14','服务发现：Zookeeper vs etcd vs Consul','','','【编者的话】本文对比了Zookeeper、etcd和Consul三种服务发现工具，探讨了最佳的服务发现解决方案，仅供参考。\n\n如果使用预定义的端口，服务越多，发生冲突的可能性越大，毕竟，不可能有两个服务监听同一个端口。管理一个拥挤的比方说被几百个服务所使用的所有端口的列表，本身就是一个挑战，添加到该列表后，这些服务需要的数据库和数量会日益增多。因此我们应该部署无需指定端口的服务，并且让Docker为我们分配一个随机的端口。唯一的问题是我们需要发现端口号，并且让别人知道。\n\n![](https://i1.wp.com/technologyconversations.com/wp-content/uploads/2015/09/single-node-docker1.png)\n\n当我们开始在一个分布式系统上部署服务到其中一台服务器上时，事情会变得更加复杂，我们可以选择预先定义哪台服务器运行哪个服务的方式，但这会导致很多问题。我们应该尽我们所能尽量利用服务器资源，但是如果预先定义每个服务的部署位置，那么要实现尽量利用服务器资源是几乎不可能的。另一个问题是服务的自动伸缩将会非常困难，更不用说自动恢复了，比方说服务器故障。另一方面，如果我们将服务部署到某台只有最少数量的容器在运行的服务器上，我们需要添加IP地址到数据列表中，这些数据需要可以被发现并存储在某处。\n\n![](https://i2.wp.com/technologyconversations.com/wp-content/uploads/2015/09/multi-node-docker1.png)\n\n当我们需要存储和发现一些与正在工作的服务相关的信息时，还有很多其他的例子。\n\n为了能够定位服务，我们需要至少接下来的两个有用的步骤。\n服务注册——该步骤存储的信息至少包括正在运行的服务的主机和端口信息\n服务发现——该步骤允许其他用户可以发现在服务注册阶段存储的信息。\n\n\n除了上述的步骤，我们还需要考虑其他方面。如果一个服务停止工作并部署/注册了一个新的服务实例，那么该服务是否应该注销呢？当有相同服务的多个副本时咋办？我们该如何做负载均衡呢？如果一个服务器宕机了咋办？所有这些问题都与注册和发现阶段紧密关联。现在，我们限定只在服务发现的范围里（常见的名字，围绕上述步骤）以及用于服务发现任务的工具，它们中的大多数采用了高可用的分布式键/值存储。\n### 服务发现工具\n服务发现工具的主要目标是用来服务查找和相互对话，为此该工具需要知道每个服务，这不是一个新概念，在Docker之前就已经存在很多类似的工具了，然而，容器带给了这些工具一个全新水平的需求。\n\n服务发现背后的基本思想是对于服务的每一个新实例（或应用程序），能够识别当前环境和存储相关信息。存储的注册表信息本身通常采用键/值对的格式，由于服务发现经常用于分布式系统，所以要求这些信息可伸缩、支持容错和分布式集群中的所有节点。这种存储的主要用途是给所有感兴趣的各方提供最起码诸如服务IP地址和端口这样的信息，用于它们之间的相互通讯，这些数据还经常扩展到其它类型的信息服务发现工具倾向于提供某种形式的API，用于服务自身的注册以及服务信息的查找。\n\n比方说我们有两个服务，一个是提供方，另一个是第一个服务的消费者，一旦部署了服务提供方，就需要在服务发现注册表中存储其信息。接着，当消费者试图访问服务提供者时，它首先查询服务注册表，使用获取到的IP地址和端口来调用服务提供者。为了与注册表中的服务提供方的具体实现解耦，我们常常采用某种代理服务。这样消费者总是向固定IP地址的代理请求信息，代理再依次使用服务发现来查找服务提供方信息并重定向请求，在本文中我们稍后通过反向代理来实现。现在重要的是要理解基于三种角色（服务消费者、提供者和代理）的服务发现流程。\n\n服务发现工具要查找的是数据，至少我们应该能够找出服务在哪里？服务是否健康和可用？配置是什么样的？既然我们正在多台服务器上构建一个分布式系统，那么该工具需要足够健壮，保证其中一个节点的宕机不会危及数据，同时，每个节点应该有完全相同的数据副本，进一步地，我们希望能够以任何顺序启动服务、杀死服务或者替换服务的新版本，我们还应该能够重新配置服务并且查看到数据相应的变化。\n\n让我们看一下一些常用的选项来完成我们上面设定的目标。\n### 手动配置\n大多数服务仍然是需要手动管理的，我们预先决定在何处部署服务、如何配置和希望不管什么原因，服务都将继续正常工作，直到天荒地老。这样的目标不是可以轻易达到的。部署第二个服务实例意味着我们需要启动全程的手动处理，我们需要引入一台新的服务器，或者找出哪一台服务器资源利用率较低，然后创建一个新的配置集并启动服务。情况或许会变得越来越复杂，比方说，硬件故障导致的手动管理下的反应时间变得很慢。可见性是另外一个痛点，我们知道什么是静态配置，毕竟是我们预先准备好的，然而，大多数的服务有很多动态生成的信息，这些信息不是轻易可见的，也没有一个单独的地方供我们在需要时参考这些数据。\n\n反应时间会不可避免的变慢，鉴于存在许多需要手动处理的移动组件，故障恢复和监控也会变得非常难以管理。\n\n尽管在过去或者当服务/服务器数量很少的时候有借口不做这项工作，随着服务发现工具的出现，这个借口已经不存在了。\n### Zookeeper\nZookeeper是这种类型的项目中历史最悠久的之一，它起源于Hadoop，帮助在Hadoop集群中维护各种组件。它非常成熟、可靠，被许多大公司（YouTube、eBay、雅虎等）使用。其数据存储的格式类似于文件系统，如果运行在一个服务器集群中，Zookeper将跨所有节点共享配置状态，每个集群选举一个领袖，客户端可以连接到任何一台服务器获取数据。\n\nZookeeper的主要优势是其成熟、健壮以及丰富的特性，然而，它也有自己的缺点，其中采用Java开发以及复杂性是罪魁祸首。尽管Java在许多方面非常伟大，然后对于这种类型的工作还是太沉重了，Zookeeper使用Java以及相当数量的依赖使其对于资源竞争非常饥渴。因为上述的这些问题，Zookeeper变得非常复杂，维护它需要比我们期望从这种类型的应用程序中获得的收益更多的知识。这部分地是由于丰富的特性反而将其从优势转变为累赘。应用程序的特性功能越多，就会有越大的可能性不需要这些特性，因此，我们最终将会为这些不需要的特性付出复杂度方面的代价。\n\nZookeeper为其他项目相当大的改进铺平了道路，“大数据玩家“在使用它，因为没有更好的选择。今天，Zookeeper已经老态龙钟了，我们有了更好的选择。\n### etcd\netcd是一个采用HTTP协议的健/值对存储系统，它是一个分布式和功能层次配置系统，可用于构建服务发现系统。其很容易部署、安装和使用，提供了可靠的数据持久化特性。它是安全的并且文档也十分齐全。\n\netcd比Zookeeper是比更好的选择，因为它很简单，然而，它需要搭配一些第三方工具才可以提供服务发现功能。\n\n![etcd.png](https://i2.wp.com/technologyconversations.com/wp-content/uploads/2015/09/etcd1.png)\n\n现在，我们有一个地方来存储服务相关信息，我们还需要一个工具可以自动发送信息给etcd。但在这之后，为什么我们还需要手动把数据发送给etcd呢？即使我们希望手动将信息发送给etcd，我们通常情况下也不会知道是什么信息。记住这一点，服务可能会被部署到一台运行最少数量容器的服务器上，并且随机分配一个端口。理想情况下，这个工具应该监视所有节点上的Docker容器，并且每当有新容器运行或者现有的一个容器停止的时候更新etcd，其中的一个可以帮助我们达成目标的工具就是Registrator。\n### Registrator\nRegistrator通过检查容器在线或者停止运行状态自动注册和去注册服务，它目前支持etcd、Consul和SkyDNS 2。\n\nRegistrator与etcd是一个简单但是功能强大的组合，可以运行很多先进的技术。每当我们打开一个容器，所有数据将被存储在etcd并传播到集群中的所有节点。我们将决定什么信息是我们的。\n\n![etcd-registrator.png](https://i1.wp.com/technologyconversations.com/wp-content/uploads/2015/09/etcd-registrator2.png)\n\n上述的拼图游戏还缺少一块，我们需要一种方法来创建配置文件，与数据都存储在etcd，通过运行一些命令来创建这些配置文件。\n### Confd\nConfd是一个轻量级的配置管理工具，常见的用法是通过使用存储在etcd、consul和其他一些数据登记处的数据保持配置文件的最新状态，它也可以用来在配置文件改变时重新加载应用程序。换句话说，我们可以用存储在etcd（或者其他注册中心）的信息来重新配置所有服务。\n\n![etcd-registrator-confd.png](https://i0.wp.com/technologyconversations.com/wp-content/uploads/2015/09/etcd-registrator-confd2.png)\n\n对于etcd、Registrator和Confd组合的最后的思考\n当etcd、Registrator和Confd结合时，可以获得一个简单而强大的方法来自动化操作我们所有的服务发现和需要的配置。这个组合还展示了“小”工具正确组合的有效性，这三个小东西可以如我们所愿正好完成我们需要达到的目标，若范围稍微小一些，我们将无法完成我们面前的目标，而另一方面如果他们设计时考虑到更大的范围，我们将引入不必要的复杂性和服务器资源开销。\n\n在我们做出最后的判决之前，让我们看看另一个有相同目标的工具组合，毕竟，我们不应该满足于一些没有可替代方案的选择。\n### Consul\nConsul是强一致性的数据存储，使用gossip形成动态集群。它提供分级键/值存储方式，不仅可以存储数据，而且可以用于注册器件事各种任务，从发送数据改变通知到运行健康检查和自定义命令，具体如何取决于它们的输出。\n\n与Zookeeper和etcd不一样，Consul内嵌实现了服务发现系统，所以这样就不需要构建自己的系统或使用第三方系统。这一发现系统除了上述提到的特性之外，还包括节点健康检查和运行在其上的服务。\n\nZookeeper和etcd只提供原始的键/值队存储，要求应用程序开发人员构建他们自己的系统提供服务发现功能。而Consul提供了一个内置的服务发现的框架。客户只需要注册服务并通过DNS或HTTP接口执行服务发现。其他两个工具需要一个亲手制作的解决方案或借助于第三方工具。\n\nConsul为多种数据中心提供了开箱即用的原生支持，其中的gossip系统不仅可以工作在同一集群内部的各个节点，而且还可以跨数据中心工作。\n\n![consul1.png](https://i2.wp.com/technologyconversations.com/wp-content/uploads/2015/09/consul2.png)\n\nConsul还有另一个不错的区别于其他工具的功能，它不仅可以用来发现已部署的服务以及其驻留的节点信息，还通过HTTP请求、TTLs（time-to-live）和自定义命令提供了易于扩展的健康检查特性。\n### Registrator\nRegistrator有两个Consul协议，其中consulkv协议产生类似于etcd协议的结果。\n\n除了通常的IP和端口存储在etcd或consulkv协议中之外，Registrator consul协议存储了更多的信息，我们可以得到服务运行节点的信息，以及服务ID和名称。我们也可以借助于一些额外的环境变量按照一定的标记存储额外的信息。\n\n![consul-registrator1.png](https://i2.wp.com/technologyconversations.com/wp-content/uploads/2015/09/consul-registrator2.png)\n\n### Consul-template\nconfd可以像和etce搭配一样用于Consul，不过Consul有自己的模板服务，其更适配Consul。\n\n通过从Consul获得的信息，Consul-template是一个非常方便的创建文件的途径，还有一个额外的好处就是在文件更新后可以运行任意命令，正如confd，Consul-template也可以使用 Go模板格式。\n\n![consul-registrator-consul-template1.png](https://i2.wp.com/technologyconversations.com/wp-content/uploads/2015/09/consul-registrator-consul-template2.png)\n\n### Consul健康检查、Web界面和数据中心\n监控集群节点和服务的健康状态与测试和部署它们一样的重要。虽然我们应该向着拥有从来没有故障的稳定的环境努力，但我们也应该承认，随时会有意想不到的故障发生，时刻准备着采取相应的措施。例如我们可以监控内存使用情况，如果达到一定的阈值，那么迁移一些服务到集群中的另外一个节点，这将是在发生“灾难”前执行的一个预防措施。另一方面，并不是所有潜在的故障都可以被及时检测到并采取措施。单个服务可能会齿白，一个完整的节点也可能由于硬件故障而停止工作。在这种情况下我们应该准备尽快行动，例如一个节点替换为一个新的并迁移失败的服务。Consul有一个简单的、优雅的但功能强大的方式进行健康检查，当健康阀值达到一定数目时，帮助用户定义应该执行的操作。\n\n如果用户Google搜索“etcd ui”或者“etec dashboard”时，用户可能看到只有几个可用的解决方案，可能会问为什么我们还没有介绍给用户，这个原因很简单，etcd只是键/值对存储，仅此而已。通过一个UI呈现数据没有太多的用处，因为我们可以很容易地通过etcdctl获得这些数据。这并不意味着etcd UI是无用的，但鉴于其有限的使用范围，它不会产生多大影响。\n\nConsu不仅仅是一个简单的键/值对存储，正如我们已经看到的，除了存储简单的键/值对，它还有一个服务的概念以及所属的数据。它还可以执行健康检查，因此成为一个好的候选dashboard，在上面可以看到我们的节点的状态和运行的服务。最后，它支持了多数据中心的概念。所有这些特性的结合让我们从不同的角度看到引入dashboard的必要性。\n\n通过Consul Web界面，用户可以查看所有的服务和节点、监控健康检查状态以及通过切换数据中心读取设置键/值对数据。\n\n![consul-nodes.png](https://i0.wp.com/technologyconversations.com/wp-content/uploads/2015/09/consul-nodes.png)\n\n### 对于Consul、Registrator、Template、健康检查和Web UI的最终思考\nConsul以及上述我们一起探讨的工具在很多情况下提供了比etcd更好的解决方案。这是从内心深处为了服务架构和发现而设计的方案，简单而强大。它提供了一个完整的同时不失简洁的解决方案，在许多情况下，这是最佳的服务发现以及满足健康检查需求的工具。\n结论\n所有这些工具都是基于相似的原则和架构，它们在节点上运行，需要仲裁来运行，并且都是强一致性的，都提供某种形式的键/值对存储。\n\nZookeeper是其中最老态龙钟的一个，使用年限显示出了其复杂性、资源利用和尽力达成的目标，它是为了与我们评估的其他工具所处的不同时代而设计的（即使它不是老得太多）。\n\netcd、Registrator和Confd是一个非常简单但非常强大的组合，可以解决大部分问题，如果不是全部满足服务发现需要的话。它还展示了我们可以通过组合非常简单和特定的工具来获得强大的服务发现能力，它们中的每一个都执行一个非常具体的任务，通过精心设计的API进行通讯，具备相对自治工作的能力，从架构和功能途径方面都是微服务方式。\n\nConsul的不同之处在于无需第三方工具就可以原生支持多数据中心和健康检查，这并不意味着使用第三方工具不好。实际上，在这篇博客里我们通过选择那些表现更佳同时不会引入不必要的功能的的工具，尽力组合不同的工具。使用正确的工具可以获得最好的结果。如果工具引入了工作不需要的特性，那么工作效率反而会下降，另一方面，如果工具没有提供工作所需要的特性也是没有用的。Consul很好地权衡了权重，用尽量少的东西很好的达成了目标。\n\nConsul使用gossip来传播集群信息的方式，使其比etcd更易于搭建，特别是对于大的数据中心。将存储数据作为服务的能力使其比etcd仅仅只有健/值对存储的特性更加完整、更有用（即使Consul也有该选项）。虽然我们可以在etcd中通过插入多个键来达成相同的目标，Consul的服务实现了一个更紧凑的结果，通常只需要一次查询就可以获得与服务相关的所有数据。除此之外，Registrator很好地实现了Consul的两个协议，使其合二为一，特别是添加Consul-template到了拼图中。Consul的Web UI更是锦上添花般地提供了服务和健康检查的可视化途径。\n\n我不能说Consul是一个明确的赢家，而是与etcd相比其有一个轻微的优势。服务发现作为一个概念，以及作为工具都很新，我们可以期待在这一领域会有许多的变化。秉承开放的心态，大家可以对本文的建议持保留态度，尝试不同的工具然后做出自己的结论。\n\n原文链接：Service Discovery: Zookeeper vs etcd vs Consul（翻译：胡震）\n原文链接： https://studygolang.com/articles/4837\n','1','2019-07-23 14:00:22','2019-07-23 14:11:46'), ('15','go get设置代理','','','直接使用`go get`安装依赖总是失败，除了翻墙还可以通过设置代理的方式。\nbash环境执行：\n```shell\n$ export GOPROXY=https://goproxy.io\n```\n\n这样就可以顺利`go get`了。\n![](http://hopefully-img.yuedun.wang/background1.png)','1','2019-05-19 23:12:00','2019-05-19 23:12:01'), ('19','markdown语法支持','','','## 3333333333333333\n\n> **34543**5\n\n![](http://hopefully-img.yuedun.wang/b43793304e9aa6d3e57f897dbe4633710d695b38506e-AoREwF_fw658.jpg)\n\n| 一个普通标题 | 一个普通标题 | 一个普通标题 |\n| ------ | ------ | ------ |\n| 短文本 | 中等文本 | 稍微长一点的文本 |\n| 稍微长一点的文本 | 短文本 | 中等文本 |\n\nName    | Age\n--------|------\nBob     | 27\nAlice   | 23','1','2019-08-16 09:46:33','2019-10-11 17:03:47'), ('20','golang项目目录结构','','','go语言和其他语言有一些区别，它是以包为单位来划分访问权限，和Java的访问粒度不一样，这注定了他们不会有相同的代码组织方式。\n\n这里推荐的项目目录组织方式是按职责划分，就是不同功能使用不同的目录。\n采用这种结构的原因是，目前流行的开发模式是微服务架构，但是一般项目的发展过程都是由小到大再到拆分的过程，如果项目初始就使用微服务的架构开发的话估计还没等项目开发完公司就完蛋了。\n所以最开始还是单体架构才是正确的方式，不过为了以后方便拆分，可以对项目目录进行合理的划分。\n从路由入口看：\n```go\nfunc RouterRegister(router *gin.Engine) {\n	//user路由注册\n    	userRouter := router.Group(\"/user\")\n    	{\n    		userRouter.GET(\"/index\", user.Index)\n    		userRouter.GET(\"/users/:id\", middleware.Auth(), user.GetUserInfo)\n    		userRouter.GET(\"/users-by-sql/:id\", user.GetUserInfoBySql)\n    		userRouter.POST(\"/\", user.CreateUser)\n    		userRouter.PUT(\"/update/:id\", user.UpdateUser)\n    		userRouter.DELETE(\"/del/:id\", user.DeleteUser)\n    	}\n    	//post路由注册\n    	postRouter := router.Group(\"/post\")\n    	{\n    		postRouter.GET(\"/\", post.Index)\n    		postRouter.GET(\"/posts/:id\", middleware.Auth(), post.GetPostInfo)\n    		postRouter.GET(\"/posts-by-sql/:id\", post.GetPostInfoBySql)\n    		postRouter.POST(\"/\", post.CreatePost)\n    		postRouter.PUT(\"/:id\", post.UpdatePost)\n    		postRouter.DELETE(\"/:id\", post.DeletePost)\n    	}\n}\n```\n本项目只是一个示例项目，模块较少，只开设了两个模块，`user`和`post`，注册路由的时候就可以按照不同的职责来分组注册，`pkg`目录下放置的就是不同职责的模块。\n将来需要对服务进行拆分的时候只需要将`pkg`目录下的模块分离出去即可形成独立的服务，对依赖的的修改也较少。如果使用的MVC架构的话，要对不同职责的服务进行拆分则很困难，需要对每一层中对应的文件都拿出来重新组织。\n\n','1','2019-09-30 16:48:17','2020-02-03 10:24:34'), ('21','测试一下写东西怎么样','','','测试一下写东西怎么样\n![](http://hopefully-img.yuedun.wang/屏幕快照 2019-10-22 05.57.49.png)\n哈哈哈哈哈','1','2019-10-04 11:10:33','2019-12-20 04:13:05'), ('22','真的假的','','','哈哈，真的假的![](http://hopefully-img.yuedun.wang/屏幕快照 2019-10-22 05.57.49.png)','1','2019-12-20 04:16:31','2019-12-20 04:16:31'), ('23','时隔半年，工作数量爬虫再次运行','','','[![](http://hopefully-img.yuedun.wang/104432cjc7c8tx7xxqqkgq.jpg)](http://hopefully-img.yuedun.wang/104432cjc7c8tx7xxqqkgq.jpg)\n\n之前做过拉钩数据爬取，但是没运行几个月，就似乎不能正常爬数据了，调试结果显示“您操作太频繁,请稍后再访问”，应该是被阻止了。偶然的使用nodejs爬了下数据，居然能爬到，就继续用go试了下，结果发现应该是cookie过期导致的，使用最新的cookie可以爬到。因为以前是写死的，肯定是过期了。那就在每次爬数据前重新获取cookie来防止过期好了。顺便修改请求客户端为beego httplib来简化代码。希望这次不会被拉黑。','1','2020-01-17 19:56:00','2020-01-17 19:58:25'), ('24','123123123','','','123123123123','1','2020-01-18 17:41:31','2020-01-18 17:41:31'), ('25','88888','','','5555555![](http://hopefully-img.yuedun.wang/cook.png)','1','2020-01-21 14:57:51','2020-01-21 14:57:51'), ('26','go-micro搭建golang微服务','','','# micro-service\ngo语言微服务[https://github.com/yuedun/micro-service](https://github.com/yuedun/micro-service)\n\n## Getting Started\n\n- [教程](https://micro.mu/docs/go-helloworld.html)\n- [用户服务](https://github.com/micro-in-cn/tutorials/tree/master/microservice-in-micro/part1)\n\n## 依赖\n\ngrpc v1.25.1，\nv1.27.1会有类型这样的错误`undefined: resolver.BuildOption`,`undefined: resolver.ResolveNowOption`\n\n## Usage\n生成*.pb.go代码\n```shell\n$ protoc --proto_path=. --micro_out=. --go_out=. proto/user/user.proto\n```\n启动服务和测试\n```shell\ngo run main.go\n```\n```shell\ngo run client/main.go\n```\n\n### 开启api服务\n```shell\ngo run main.go\n```\n```shell\ngo run api/api.go\n```\n```shell\nmicro api --handler=api\n```\n```shell\ncurl \"http://localhost:8080/user/say/hello?name=huohuo\"\n```\n返回\n{\"id\":\"123\",\"password\":\"dslhgfoif40u9b9\",\"username\":\"huohuo\"}\n\n### api层说明：\nAPI模块，它的身份其实就是一个网关或者代理层，它的能力就是让一个单一的入口可以去访问微服务。API工作在我们的软件服务架构的边缘。\n\n## 服务注册服务\nv2.0版本默认使用的服务注册发现是**mdns**。\nMicro内置了mDNS组播系统，这是一种零依赖的服务注册发现机制，它是区别于有注册中心的替代方案。\n通过在启动指令中传入--registry=mdns 或者在环境变量中设置MICRO_REGISTRY=mdns。\n其实也可以不传，早期版本的go-micro默认注册中心是consul，现在换成了mdns\nmDNS（多播DNS）是一种局域网内使用的DNS机制，他的大致原理如下：当有新的节点加入局域网的时候，如果打开了mDNS，就主动向局域网其他所有节点广播，自己提供的服务（域名是什么、ip地址是什么、端口号是什么）, 这样我们任何一个节点都知道局域网提供了什么服务。\n所以生产环境需要其他中间件，如**consul**，**etcd**。\n\n## 使用etcd作为服务发现中间件\ngo-micro v2弃用了**consul**，推荐使用的是**etcd**。\n使用方法：\n```shell\ngo run main.go --registry=etcd\n```\n```shell\ngo run api/api.go --registry=etcd\n```\n```shell\nmicro --registry=etcd api --handler=api\n```\n在启动的时候加上`--registry=etcd`参数即可，启动日志如下：\n```cassandraql\n2020-03-14 16:17:07 Starting [service] go.micro.srv.user\n2020-03-14 16:17:07 Server [grpc] Listening on [::]:10507\n2020-03-14 16:17:07 Registry [etcd] Registering node: go.micro.srv.user-332fd9a8-f241-4c20-bf93-ee832b487261\n```\n`Registry [mdns]`变成了`Registry [etcd]`。\n### 启动三个etcd实例：\n```shell\n.\\etcd.exe --name etcd01 ^\n--data-dir .\\data\\etcd01 ^\n--advertise-client-urls http://127.0.0.1:2379 ^\n--listen-client-urls http://127.0.0.1:2379 ^\n--listen-peer-urls http://127.0.0.1:2380 ^\n--initial-advertise-peer-urls http://127.0.0.1:2380 ^\n--initial-cluster-token etcd-cluster-1 ^\n--initial-cluster etcd01=http://127.0.0.1:2380,etcd02=http://127.0.0.1:2381,etcd03=http://127.0.0.1:2382 ^\n--initial-cluster-state new\n\npause\n```\n```shell\n.\\etcd.exe --name etcd02 ^\n--data-dir .\\data\\etcd02 ^\n--advertise-client-urls http://127.0.0.1:3379 ^\n--listen-client-urls http://127.0.0.1:3379 ^\n--listen-peer-urls http://127.0.0.1:2381 ^\n--initial-advertise-peer-urls http://127.0.0.1:2381 ^\n--initial-cluster-token etcd-cluster-1 ^\n--initial-cluster etcd01=http://127.0.0.1:2380,etcd02=http://127.0.0.1:2381,etcd03=http://127.0.0.1:2382 ^\n--initial-cluster-state new\n\npause\n```\n```shell\n.\\etcd.exe --name etcd03 ^\n--data-dir .\\data\\etcd03 ^\n--advertise-client-urls http://127.0.0.1:4379 ^\n--listen-client-urls http://127.0.0.1:4379 ^\n--listen-peer-urls http://127.0.0.1:2382 ^\n--initial-advertise-peer-urls http://127.0.0.1:2382 ^\n--initial-cluster-token etcd-cluster-1 ^\n--initial-cluster etcd01=http://127.0.0.1:2380,etcd02=http://127.0.0.1:2381,etcd03=http://127.0.0.1:2382 ^\n--initial-cluster-state new\n\npause\n```\n查看etcd节点状态\n```shell\n./etcdctl.exe --write-out=table --endpoints=http://127.0.0.1:2379,http://127.0.0.1:3379,http://127.0.0.1:4379 endpoint status\n```\n```shell\n+-----------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+\n|       ENDPOINT        |        ID        | VERSION | DB SIZE | IS LEADER | IS LEARNER | RAFT TERM | RAFT INDEX | RAFT APPLIED INDEX | ERRORS |\n+-----------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+\n| http://127.0.0.1:2379 | bf9071f4639c75cc |   3.4.4 |  115 kB |      true |      false |        13 |         99 |                 99 |        |\n| http://127.0.0.1:3379 | e7b968b9fb1bc003 |   3.4.4 |  115 kB |     false |      false |        13 |         99 |                 99 |        |\n| http://127.0.0.1:4379 | 19ac17627e3e396f |   3.4.4 |  106 kB |     false |      false |        13 |         99 |                 99 |        |\n+-----------------------+------------------+---------+---------+-----------+------------+-----------+------------+--------------------+--------+\n\n```\n启动两个新的服务并注册到etcd中\n```shell\n go run main.go --registry=etcd --registry_address=http://127.0.0.1:3379\n```\n```shell\n go run main.go --registry=etcd --registry_address=http://127.0.0.1:4379\n```\n多次请求http://localhost:8080/user/say/hello?name=huohuo\n会在三个服务轮询接收请求\n![](./etcd.jpg)\n停止某个服务并不会中断服务，以此实现了服务注册发现。','1','2020-03-16 14:21:26','2020-07-21 17:30:33'), ('27','祝大家五一快乐','','','五一长假，出行安全，吃喝玩乐，走亲访友，阖家欢乐','1','2020-05-01 10:49:13','2020-05-01 10:49:13'), ('28','dfsaf','','','fdsafdasfds','1','2020-05-03 21:45:04','2020-05-03 21:45:04'), ('29','1111','','','11111','1','2020-05-19 14:28:18','2020-05-19 14:28:18'), ('30','棒棒哒！','','','预祝周末愉快\nGo Go Go, 学起来！！！\nFrom Elsa','1','2020-05-29 10:23:34','2020-07-18 17:07:11'), ('31','213','','','12312312','1','2020-06-13 17:18:06','2020-06-13 17:18:06'), ('32','hello','','','！','1','2020-07-05 01:47:11','2020-07-05 01:47:11'), ('33','更新UI','','','本次更新UI，使得整体看起来更大气，同时在移动端布局更合理。\n\n本站基于golang语言，beego框架开发。项目同时包含了用户界面和管理后台，无需部署两个服务，同时提供了数据库结构，可直接拿来使用。 本项目对个人用户友好，前端使用了最原始的html，js，css开发无需搭建繁琐的开发环境，不追求高大上（假大空）的技术，返璞归真，让个人网站更易建立。','1','2020-07-18 12:12:03','2020-07-18 12:12:03'), ('34','友情告知','','','**亲爱的朋友们，很高兴您访问本站。**\n\n但是，您可能无法从本站看到有用的文章。本站目前只是作为一个供广大网友学习golang的项目，网站中暂不会发表重要文章，因为本站直接提供了登录后台的账号和入口，会有网友们测试发表的内容，看看就行，不要当真。也希望大家不要胡乱发表内容。','1','2020-07-19 15:56:44','2020-11-08 11:48:49'), ('35','权限控制设计','权限设计','架构','权限往往是一个极其复杂的问题，但也可简单表述为这样的逻辑表达式：判断“Who对What(Which)进行How的操作”的逻辑表达式是否为真。针对不同的应用，需要根据项目的实际情况和具体架构，在维护性、灵活性、完整性等N多个方案之间比较权衡，选择符合的方案。\n\n**目标：**\n直观，因为系统最终会由最终用户来维护，权限分配的直观和容易理解，显得比较重要，系统不辞劳苦的实现了组的继承，除了功能的必须，更主要的就是因为它足够直观。\n\n简单，包括概念数量上的简单和意义上的简单还有功能上的简单。想用一个权限系统解决所有的权限问题是不现实的。设计中将常常变化的“定制”特点比较强的部分判断为业务逻辑，而将常常相同的“通用”特点比较强的部分判断为权限逻辑就是基于这样的思路。\n\n扩展，采用可继承在扩展上的困难。的Group概念在支持权限以组方式定义的同时有效避免了重定义时\n\n**现状：**\n对于在企业环境中的访问控制方法，一般有三种：\n\n1.自主型访问控制方法。目前在我国的大多数的信息系统中的访问控制模块中基本是借助于自主型访问控制方法中的访问控制列表(ACLs)。\n\n2.强制型访问控制方法。用于多层次安全级别的军事应用。\n\n3.基于角色的访问控制方法（RBAC）。是目前公认的解决大型企业的统一资源访问控制的有效方法。\n其显著的两大特征是：1.减小授权管理的复杂性，降低管理开销。2.灵活地支持企业的安全策略，并对企业的变化有很大的伸缩性。\n\n**名词：**\n粗粒度：表示类别级，即仅考虑对象的类别(the type of object)，不考虑对象的某个特定实例。比如，用户管理中，创建、删除，对所有的用户都一视同仁，并不区分操作的具体对象实例。\n\n细粒度：表示实例级，即需要考虑具体对象的实例(the instance of object)，当然，细粒度是在考虑粗粒度的对象类别之后才再考虑特定实例。比如，合同管理中，列表、删除，需要区分该合同实例是否为当前用户所创建。\n\n**原则：**\n权限逻辑配合业务逻辑。即权限系统以为业务逻辑提供服务为目标。相当多细粒度的权限问题因其极其独特而不具通用意义，它们也能被理解为是“业务逻辑”的一部分。比如，要求：“合同资源只能被它的创建者删除，与创建者同组的用户可以修改，所有的用户能够浏览”。这既可以认为是一个细粒度的权限问题，也可以认为是一个业务逻辑问题。在这里它是业务逻辑问题，在整个权限系统的架构设计之中不予过多考虑。当然，权限系统的架构也必须要能支持这样的控制判断。或者说，系统提供足够多但不是完全的控制能力。即，设计原则归结为：“系统只提供粗粒度的权限，细粒度的权限被认为是业务逻辑的职责”。\n\n需要再次强调的是，这里表述的权限系统仅是一个“不完全”的权限系统，即，它不提供所有关于权限的问题的解决方法。它提供一个基础，并解决那些具有“共性”的(或者说粗粒度的)部分。在这个基础之上，根据“业务逻辑”的独特权限需求，编码实现剩余部分(或者说细粒度的)部分，才算完整。回到权限的问题公式，通用的设计仅解决了Who+What+How 的问题，其他的权限问题留给业务逻辑解决。\n\n**概念：**\n\n- Who：权限的拥用者或主体（Principal、User、Group、Role、Actor等等）\n- What：权限针对的对象或资源（Resource、Class）。\n- How：具体的权限（Privilege, 正向授权与负向授权）。\n- Role：是角色，拥有一定数量的权限。\n- Operator：操作。表明对What的How 操作。\n\n**说明：**\nUser：与 Role 相关，用户仅仅是纯粹的用户，权限是被分离出去了的。User是不能与 Privilege 直接相关的，User 要拥有对某种资源的权限，必须通过Role去关联。解决 Who 的问题。\n\nResource：就是系统的资源，比如部门新闻，文档等各种可以被提供给用户访问的对象。资源可以反向包含自身，即树状结构，每一个资源节点可以与若干指定权限类别相关可定义是否将其权限应用于子节点。\n\nPrivilege：是Resource Related的权限。就是指，这个权限是绑定在特定的资源实例上的。比如说部门新闻的发布权限，叫做\"部门新闻发布权限\"。\n这就表明，该Privilege是一个发布权限，而且是针对部门新闻这种资源的一种发布权限。Privilege是由Creator在做开发时就确定的。权限，包括系统定义权限和用户自定义权限用户自定义权限之间可以指定排斥和包含关系(如：读取，修改，管理三个权限，管理 权限 包含 前两种权限)。Privilege 如\"删除\" 是一个抽象的名词，当它不与任何具体的 Object 或 Resource 绑定在一起时是没有任何意义的。拿新闻发布来说，发布是一种权限，但是只说发布它是毫无意义的。因为不知道发布可以操作的对象是什么。只有当发布与新闻结合在一起时，才会产生真正的 Privilege。这就是 Privilege Instance。权限系统根据需求的不同可以延伸生很多不同的版本。\n\nRole：是粗粒度和细粒度(业务逻辑)的接口，一个基于粗粒度控制的权限框架软件，对外的接口应该是Role，具体业务实现可以直接继承或拓展丰富Role的内容，Role不是如同User或Group的具体实体，它是接口概念，抽象的通称。\n\nGroup：用户组，权限分配的单位与载体。权限不考虑分配给特定的用户。组可以包括组(以实现权限的继承)。组可以包含用户，组内用户继承组的权限。Group要实现继承。即在创建时必须要指定该Group的Parent是什么Group。在粗粒度控制上，可以认为，只要某用户直接或者间接的属于某个Group那么它就具备这个Group的所有操作许可。细粒度控制上，在业务逻辑的判断中，User仅应关注其直接属于的Group，用来判断是否“同组” 。Group是可继承的，对于一个分级的权限实现，某个Group通过“继承”就已经直接获得了其父Group所拥有的所有“权限集合”，对这个Group而言，需要与权限建立直接关联的，仅是它比起其父Group需要“扩展”的那部分权限。子组继承父组的所有权限，规则来得更简单，同时意味着管理更容易。为了更进一步实现权限的继承，最直接的就是在Group上引入“父子关系”。\n\nUser与Group是多对多的关系。即一个User可以属于多个Group之中，一个Group可以包括多个User。子Group与父Group是多对一的关系。Operator某种意义上类似于Resource + Privilege概念，但这里的Resource仅包括Resource Type不表示Resource Instance。Group 可以直接映射组织结构，Role 可以直接映射组织结构中的业务角色，比较直观，而且也足够灵活。Role对系统的贡献实质上就是提供了一个比较粗颗粒的分配单位。\nGroup与Operator是多对多的关系。各概念的关系图示如下：\n\n**解释：**\nOperator的定义包括了Resource Type和Method概念。即，What和How的概念。之所以将What和How绑定在一起作为一个Operator概念而不是分开建模再建立关联，这是因为很多的How对于某What才有意义。比如，发布操作对新闻对象才有意义，对用户对象则没有意义。\n\nHow本身的意义也有所不同，具体来说，对于每一个What可以定义N种操作。比如，对于合同这类对象，可以定义创建操作、提交操作、检查冲突操作等。可以认为，How概念对应于每一个商业方法。其中，与具体用户身份相关的操作既可以定义在操作的业务逻辑之中，也可以定义在操作级别。比如，创建者的浏览视图与普通用户的浏览视图要求内容不同。既可以在外部定义两个操作方法，也可以在一个操作方法的内部根据具体逻辑进行处理。具体应用哪一种方式应依据实际情况进行处理。\n\n这样的架构，应能在易于理解和管理的情况下，满足绝大部分粗粒度权限控制的功能需要。但是除了粗粒度权限，系统中必然还会包括无数对具体Instance的细粒度权限。这些问题，被留给业务逻辑来解决，这样的考虑基于以下两点：\n一方面，细粒度的权限判断必须要在资源上建模权限分配的支持信息才可能得以实现。比如，如果要求创建者和普通用户看到不同的信息内容，那么，资源本身应该有其创建者的信息。另一方面，细粒度的权限常常具有相当大的业务逻辑相关性。对不同的业务逻辑，常常意味着完全不同的权限判定原则和策略。相比之下，粗粒度的权限更具通用性，将其实现为一个架构，更有重用价值；而将细粒度的权限判断实现为一个架构级别的东西就显得繁琐，而且不是那么的有必要，用定制的代码来实现就更简洁，更灵活。\n\n所以细粒度控制应该在底层解决，Resource在实例化的时候，必需指定Owner和GroupPrivilege在对Resource进行操作时也必然会确定约束类型：究竟是OwnerOK还是GroupOK还是AllOK。Group应和Role严格分离User和Group是多对多的关系，Group只用于对用户分类，不包含任何Role的意义；Role只授予User，而不是Group。如果用户需要还没有的多种Privilege的组合，必须新增Role。Privilege必须能够访问Resource，同时带User参数，这样权限控制就完备了。\n\n**思想：**\n权限系统的核心由以下三部分构成：1.创造权限，2.分配权限，3.使用权限，然后，系统各部分的主要参与者对照如下：1.创造权限 - Creator创造，2.分配权限 - Administrator 分配，3.使用权限 - User：\n\n1. Creator 创造 Privilege， Creator 在设计和实现系统时会划分，一个子系统或称为模块，应该有哪些权限。这里完成的是 Privilege 与 Resource 的对象声明，并没有真正将 Privilege 与具体Resource 实例联系在一起，形成Operator。\n\n2. Administrator 指定 Privilege 与 Resource Instance 的关联。在这一步， 权限真正与资源实例联系到了一起， 产生了Operator（Privilege Instance）。Administrator利用Operator这个基本元素，来创造他理想中的权限模型。如，创建角色，创建用户组，给用户组分配用户，将用户组与角色关联等等...这些操作都是由 Administrator 来完成的。\n\n3. User 使用 Administrator 分配给的权限去使用各个子系统。Administrator 是用户，在他的心目中有一个比较适合他管理和维护的权限模型。于是，程序员只要回答一个问题，就是什么权限可以访问什么资源，也就是前面说的 Operator。程序员提供 Operator 就意味着给系统穿上了盔甲。Administrator 就可以按照他的意愿来建立他所希望的权限框架可以自行增加，删除，管理Resource和Privilege之间关系。可以自行设定用户User和角色Role的对应关系。(如果将 Creator看作是 Basic 的发明者， Administrator 就是 Basic 的使用者，他可以做一些脚本式的编程) Operator是这个系统中最关键的部分，它是一个纽带，一个系在Programmer，Administrator，User之间的纽带。\n\n用一个功能模块来举例子。\n#### 一．建立角色功能并做分配：\n1．如果现在要做一个员工管理的模块(即Resources)，这个模块有三个功能，分别是：增加，修改，删除。给这三个功能各自分配一个ID，这个ID叫做功能代号：\nEmp_addEmp，Emp_deleteEmp，Emp_updateEmp。\n\n2．建立一个角色(Role)，把上面的功能代码加到这个角色拥有的权限中，并保存到数据库中。角色包括系统管理员，测试人员等。\n\n3．建立一个员工的账号，并把一种或几种角色赋给这个员工。比如说这个员工既可以是公司管理人员，也可以是测试人员等。这样他登录到系统中将会只看到他拥有权限的那些模块。\n\n#### 二．把身份信息加到Session中。\n登录时，先到数据库中查找是否存在这个员工，如果存在，再根据员工的sn查找员工的权限信息，把员工所有的权限信息都入到一个Hashmap中，比如就把上面的Emp_addEmp等放到这个Hashmap中。然后把Hashmap保存在一个UserInfoBean中。最后把这个UserInfoBean放到Session中，这样在整个程序的运行过程中，系统随时都可以取得这个用户的身份信息。\n\n#### 三．根据用户的权限做出不同的显示。\n\n可以对比当前员工的权限和给这个菜单分配的“功能ID”判断当前用户是否有打开这个菜单的权限。例如：如果保存员工权限的Hashmap中没有这三个ID的任何一个，那这个菜单就不会显示，如果员工的Hashmap中有任何一个ID，那这个菜单都会显示。\n\n对于一个新闻系统(Resouce)，假设它有这样的功能(Privilege)：查看，发布，删除，修改；假设对于删除，有\"新闻系统管理者只能删除一月前发布的，而超级管理员可删除所有的这样的限制，这属于业务逻辑(Business logic)，而不属于用户权限范围。也就是说权限负责有没有删除的Permission，至于能删除哪些内容应该根据UserRole or UserGroup来决定(当然给UserRole or UserGroup分配权限时就应该包含上面两条业务逻辑)。\n\n一个用户可以拥有多种角色，但同一时刻用户只能用一种角色进入系统。角色的划分方法可以根据实际情况划分，按部门或机构进行划分的，至于角色拥有多少权限，这就看系统管理员赋给他多少的权限了。用户—角色—权限的关键是角色。用户登录时是以用户和角色两种属性进行登录的（因为一个用户可以拥有多种角色，但同一时刻只能扮演一种角色），根据角色得到用户的权限，登录后进行初始化。这其中的技巧是同一时刻某一用户只能用一种角色进行登录。\n针对不同的“角色”动态的建立不同的组，每个项目建立一个单独的Group，对于新的项目，建立新的 Group 即可。在权限判断部分，应在商业方法上予以控制。比如：不同用户的“操作能力”是不同的(粗粒度的控制应能满足要求)，不同用户的“可视区域”是不同的(体现在对被操作的对象的权限数据，是否允许当前用户访问，这需要对业务数据建模的时候考虑权限控制需要)。\n\n**扩展性：**\n有了用户/权限管理的基本框架，Who(User/Group)的概念是不会经常需要扩展的。变化的可能是系统中引入新的 What (新的Resource类型)或者新的How(新的操作方式)。那在三个基本概念中，仅在Permission上进行扩展是不够的。这样的设计中Permission实质上解决了How 的问题，即表示了“怎样”的操作。那么这个“怎样”是在哪一个层次上的定义呢？将Permission定义在“商业方法”级别比较合适。比如，发布、购买、取消。每一个商业方法可以意味着用户进行的一个“动作”。定义在商业逻辑的层次上，一方面保证了数据访问代码的“纯洁性”，另一方面在功能上也是“足够”的。也就是说，对更低层次，能自由的访问数据，对更高层次，也能比较精细的控制权限。\n\n确定了Permission定义的合适层次，更进一步，能够发现Permission实际上还隐含了What的概念。也就是说，对于What的How操作才会是一个完整的Operator。比如，“发布”操作，隐含了“信息”的“发布”概念，而对于“商品”而言发布操作是没有意义的。同样的，“购买”操作，隐含了“商品”的“购买”概念。这里的绑定还体现在大量通用的同名的操作上，比如，需要区分“商品的删除”与“信息的删除”这两个同名为“删除”的不同操作。\n\n提供权限系统的扩展能力是在Operator (Resource + Permission)的概念上进行扩展。Proxy 模式是一个非常合适的实现方式。实现大致如下：在业务逻辑层(EJB Session Facade [Stateful SessionBean]中)，取得该商业方法的Methodname，再根据Classname和 Methodname 检索Operator 数据，然后依据这个Operator信息和Stateful中保存的User信息判断当前用户是否具备该方法的操作权限。\n\n应用在 EJB 模式下，可以定义一个很明确的 Business层次，而一个Business 可能意味着不同的视图，当多个视图都对应于一个业务逻辑的时候，比如，Swing Client以及 Jsp Client 访问的是同一个 EJB 实现的 Business。在 Business 层上应用权限较能提供集中的控制能力。实际上，如果权限系统提供了查询能力，那么会发现，在视图层次已经可以不去理解权限，它只需要根据查询结果控制界面就可以了。\n\n**灵活性：**\nGroup和Role，只是一种辅助实现的手段，不是必需的。如果系统的Role很多，逐个授权违背了“简单，方便”的目的，那就引入Group，将权限相同的Role组成一个Group进行集中授权。Role也一样，是某一类Operator的集合，是为了简化针对多个Operator的操作。\n\nRole把具体的用户和组从权限中解放出来。一个用户可以承担不同的角色，从而实现授权的灵活性。当然，Group也可以实现类似的功能。但实际业务中，Group划分多以行政组织结构或业务功能划分；如果为了权限管理强行将一个用户加入不同的组，会导致管理的复杂性。\n\nDomain的应用。为了授权更灵活，可以将Where或者Scope抽象出来，称之为Domain，真正的授权是在Domain的范围内进行，具体的Resource将分属于不同的Domain。比如：一个新闻机构有国内与国外两大分支，两大分支内又都有不同的资源（体育类、生活类、时事政治类）。假如所有国内新闻的权限规则都是一样的，所有国外新闻的权限规则也相同。则可以建立两个域，分别授权，然后只要将各类新闻与不同的域关联，受域上的权限控制，从而使之简化。\n\n权限系统还应该考虑将功能性的授权与资源性的授权分开。很多系统都只有对系统中的数据（资源）的维护有权限控制，但没有对系统功能的权限控制。\n\n权限系统最好是可以分层管理而不是集中管理。大多客户希望不同的部门能且仅能管理其部门内部的事务，而不是什么都需要一个集中的Administrator或Administrators组来管理。虽然你可以将不同部门的人都加入Administrators组，但他们的权限过大，可以管理整个系统资源而不是该部门资源。\n\n正向授权与负向授权：正向授权在开始时假定主体没有任何权限，然后根据需要授予权限，适合于权限要求严格的系统。负向授权在开始时假定主体有所有权限，然后将某些特殊权限收回。\n权限计算策略：系统中User，Group，Role都可以授权，权限可以有正负向之分，在计算用户的净权限时定义一套策略。\n\n系统中应该有一个集中管理权限的AccessService，负责权限的维护（业务管理员、安全管理模块）与使用（最终用户、各功能模块），该AccessService在实现时要同时考虑一般权限与特殊权限。虽然在具体实现上可以有很多，比如用Proxy模式，但应该使这些Proxy依赖于AccessService。各模块功能中调用AccessService来检查是否有相应的权限。所以说，权限管理不是安全管理模块自己一个人的事情，而是与系统各功能模块都有关系。每个功能模块的开发人员都应该熟悉安全管理模块，当然，也要从业务上熟悉本模块的安全规则。\n\n**技术实现：**\n\n1．表单式认证，这是常用的，但用户到达一个不被授权访问的资源时，Web容器就发出一个html页面，要求输入用户名和密码。\n\n2．一个基于Servlet Sign in/Sign out来集中处理所有的Request，缺点是必须由应用程序自己来处理。\n3．用Filter防止用户访问一些未被授权的资源，Filter会截取所有Request/Response，然后放置一个验证通过的标识在用户的Session中，然后Filter每次依靠这个标识来决定是否放行Response。\n\n**这个模式分为：**\n\nGatekeeper ：采取Filter或统一Servlet的方式。\n\nAuthenticator： 在Web中使用JAAS自己来实现。\n\n用户资格存储LDAP或数据库：\n\n1. Gatekeeper拦截检查每个到达受保护的资源。首先检查这个用户是否有已经创建好的Login Session，如果没有，Gatekeeper 检查是否有一个全局的和Authenticator相关的session？\n\n2. 如果没有全局的session，这个用户被导向到Authenticator的Sign-on 页面，要求提供用户名和密码。\n3. Authenticator接受用户名和密码，通过用户的资格系统验证用户。\n\n4. 如果验证成功，Authenticator将创建一个全局Login session，并且导向Gatekeeper来为这个用户在他的web应用中创建一个Login Session。\n\n5. Authenticator和Gatekeepers联合分享Cookie，或者使用Tokens在Query字符里。','1','2020-07-29 18:11:37','2020-08-02 18:38:14'), ('36','123','123123','231231','12312312','1','2020-08-13 11:30:19','2020-08-13 11:30:19'), ('37','postman使用技巧','postman','工具使用','postman是开发人员必备的接口测试工具，虽然经常使用，但是并不会使用到所有功能，除了简单的接口测试外，它还有很多实用的功能，如果充分利用起来，能使我们的工作事半功倍。\n\n- 环境变量的使用\n- 捕获请求和cookie\n- 收藏接口与分享接口\n- 批量测试\n- 编写文档和示例\n\n## 环境变量的使用\n环境变量的作用是使用切换变量的方式代替频繁的环境修改。这样我们只需保存一次测试接口就可以在不同环境下使用。\n举例：\n\n**环境变量配置**\n\n![环境变量配置](http://hopefully-img.yuedun.wang/env.jpg)\n\n**环境变量使用**\n\n![环境变量使用](http://hopefully-img.yuedun.wang/env3.jpg)\n\n**环境变量切换**\n\n![环境变量切换](http://hopefully-img.yuedun.wang/env2.jpg)\n\n## 捕获请求和cookie\n能够直接将浏览器中的请求和cookie同步到postman，省去手动复制请求接口和cookie到postman中。\n同时，对于需要登录后使用的接口，postman可以直接使用浏览器的登录状态，而不必复制cookie。\n举例：\n![捕获请求](http://hopefully-img.yuedun.wang/capturerequest.gif)\n\n## 收藏接口与分享接口\n将自己保存的接口分享与他人，直接拿来即可使用。\n如果安装了Chrome插件，则可以直接的浏览器中打开链接。使用客户端需要使用import来导入。\n![分享接口](http://hopefully-img.yuedun.wang/分享接口.png)\n\n## 批量测试\n保存的多个接口批量测试。\n![接口批量测试](http://hopefully-img.yuedun.wang/batchtest.gif)\n\n## 编写文档和示例\n对于团队协作很有用，接口交流利器。不仅有了请求参数，添加一个example还可以看到接口返回参数。\n![](http://hopefully-img.yuedun.wang/document.jpg)\n\n原文：http://www.yuedun.wang/blogdetail/5fa0f8e55edb9b37630b65f7','1','2020-11-03 15:22:40','2020-11-03 16:06:01');

INSERT INTO `groups` VALUES ('6','2','3','2018-04-28 17:35:30','2018-04-28 17:35:32'), ('7','2','1','2018-04-28 13:16:33','2018-04-28 13:16:36'), ('8','2','2','2018-06-11 13:10:12','2018-06-11 13:10:15'), ('9','2','4','2018-06-11 13:10:25','2018-06-11 13:10:28'), ('10','2','5','2018-06-11 13:10:38','2018-06-11 13:10:40'), ('11','2','6','2018-06-11 13:10:50','2018-06-11 13:10:55'), ('12','2','7','2019-02-15 15:25:02','2019-02-15 15:25:02'), ('15','2','8','2019-02-16 14:21:49','2019-02-16 14:21:49'), ('16','1','1','2019-05-08 14:58:10','2019-05-08 14:58:10'), ('17','25','2','2019-05-08 14:58:37','2019-05-08 14:58:37'), ('20','23','6','2019-05-19 23:10:19','2019-05-19 23:10:19'), ('21','13','7','2019-06-28 14:40:07','2019-06-28 14:40:07'), ('22','13','6','2019-06-28 14:40:07','2019-06-28 14:40:07'), ('23','14','8','2019-07-28 19:22:27','2019-07-28 19:22:27'), ('24','14','7','2019-07-28 19:22:27','2019-07-28 19:22:27'), ('25','14','6','2019-07-28 19:22:27','2019-07-28 19:22:27'), ('26','1','8','2019-08-16 10:08:42','2019-08-16 10:08:42'), ('27','1','7','2019-08-16 10:08:42','2019-08-16 10:08:42'), ('29','5','8','2019-08-16 10:08:59','2019-08-16 10:08:59'), ('30','5','3','2019-08-16 10:08:59','2019-08-16 10:08:59'), ('33','8','8','2019-08-16 10:11:18','2019-08-16 10:11:18'), ('34','8','3','2019-08-16 10:11:18','2019-08-16 10:11:18'), ('36','28','8','2019-09-03 14:50:28','2019-09-03 14:50:28'), ('43','13','8','2019-09-17 10:40:41','2019-09-17 10:40:41');
INSERT INTO `helpers` VALUES ('1','张三','18734587454','zhangsan@qq.com',NULL,'教学工作站,销售工作站','2017-10-24 23:11:10','2017-10-24 23:11:14'), ('2','李四','12222222222','12222222222@163.com',NULL,'财务工作站,用户管理','2017-11-18 15:30:06','2017-11-18 15:30:09');

INSERT INTO `picture` VALUES ('1','//static.cnodejs.org/Ft685Ah4vM0Z3QLB_Kht2YnTDNp9','0','Microtask,Macrotask','2019-03-20 10:06:55','2019-03-20 10:06:55'), ('2','http://dockone.io/uploads/article/20150913/e31fd491a376d3398fd4ca2dfcc98a9c.png','1','','2019-05-15 16:42:35','2019-05-15 16:42:35'), ('3','','0','','2019-05-19 23:17:32','2019-05-19 23:17:32'), ('4','','0','','2019-05-19 23:18:35','2019-05-19 23:18:35'), ('5','','0','','2019-09-30 14:38:08','2019-09-30 14:38:08'), ('6','','0','','2019-10-24 13:39:29','2019-10-24 13:39:29'), ('7','','0','','2019-10-24 13:40:07','2019-10-24 13:40:07'), ('8','','0','','2019-10-24 13:40:09','2019-10-24 13:40:09'), ('9','','0',',,','2019-10-24 13:40:48','2019-10-24 13:40:48'), ('10','','0',',','2019-10-24 13:43:25','2019-10-24 13:43:25'), ('11','','0','','2019-11-13 18:07:05','2019-11-13 18:07:05'), ('12','','0','','2019-12-14 17:06:59','2019-12-14 17:06:59'), ('13','http://5b0988e595225.cdn.sohucs.com/images/20190807/a1061be84397443ea273736378690cdd.png','1','持续集成（CI）,持续交付和持续部署（CD）,CI/CD的优势','2020-03-25 16:33:12','2020-03-25 16:33:12');
INSERT INTO `role` VALUES ('1','AdminController:UserList,AdminController:UserListRoute','管理员','2018-04-21 14:00:18','2018-04-21 14:00:23'), ('2','AdminController:UserListRoute','普通管理员','2018-04-21 14:00:15','2018-04-21 14:00:21'), ('3','AdminController:POST','添加用户','2018-04-20 13:29:49','2018-04-20 13:29:52'), ('4','AdminController:PUT','编辑用户','2018-06-11 13:05:02','2018-06-11 13:05:05'), ('5','AdminController:DeleteUser','删除用户','2018-06-11 13:07:02','2018-06-11 13:07:07'), ('6','AdminController:UserList','用户列表','2018-06-11 13:09:09','2018-06-11 13:09:12'), ('7','AdminController:ArticleEdit','编辑文章','2019-02-15 13:37:51','2019-02-15 13:37:55'), ('8','AdminController:ArticleDelete','删除文章','2019-02-16 14:21:04','2019-02-16 14:21:07');
INSERT INTO `user` VALUES ('1','13477889900','犬夜叉33','960232f4a37f948b480a3f8a5512c6f8','1','13477889900@139.com','日暮神社','0','半妖','2018-03-17 20:46:31','2020-04-21 13:38:10'), ('2','18701897513','戈薇','abc72b24857be42850f67d3160f8710e','1','18701897513@139.com','日暮神社','1','博主我感觉你好牛批','2018-03-17 20:49:44','2019-10-21 17:11:58'), ('5','18701893513','桔梗','abc72b24857be42850f67d3160f8710e','0','18611118146@139.com','看见的任何司空见惯和','0','奈落都害怕的女人','2017-07-27 03:25:01','2019-08-16 09:41:42'), ('8','10701897527','弥勒','8fa2952fff72d92c98f9f43e46dfc6bd','0','huo@gmail.com','吉林大街好地方','0','而喝了酒而温柔你感觉','2017-07-27 09:00:43','2018-03-19 11:10:50'), ('9','10706597527','七宝1','8fa2952fff72d92c98f9f43e46dfc6bd','0','438473@qq.com','发顺丰','0','收到了架构过人家饿啊人工','2017-07-29 10:38:06','2019-09-02 15:03:46'), ('13','18701497527','杀生丸','8fa2952fff72d92c98f9f43e46dfc6bd','1','hp@sina.com','送就送山东黄金人数','1','视频国际投行饿哦日后我如何进入','2018-02-05 04:20:37','2018-12-02 20:38:37'), ('14','12345678909','珊瑚','5335412ee0f17806e1017e607149336a','0','ligh@163.com','很快就都大佛开盘后具体要','1','我感觉哦过仁和堂撒今天','2018-02-05 08:07:37','2018-04-06 17:03:04'), ('21','18721897527','奈落','8fa2952fff72d92c98f9f43e46dfc6bd','1','18611118146@139.com','送就送山东黄金人数几乎是丢改好','1','就fdfda','2018-02-11 07:53:18','2018-10-24 11:43:07'), ('22','18766464985','云母','442ba06a1ac9ad299865c11234b9c492','0','ligh@163.com','送就送山东黄金人数几乎是丢改好看机会','1','','2018-02-11 15:58:10','2019-02-24 21:01:36'), ('23','12335678909','邪见','5335412ee0f17806e1017e607149336a','1','13344442929@163.com','看见的任何','0','','2018-02-11 16:05:53','2019-02-24 21:01:51'), ('25','18111897528','铃','033554527363fed57bacfcab7c77c5fb','0','lig@163.com','dfpkgipniu','0','当人看了韩国人都','2018-02-28 10:34:39','2019-02-24 21:02:23'), ('26','18765464985','神乐','442ba06a1ac9ad299865c11234b9c492','0','13344442929@163.com','很快就都大佛开盘后具体要','0','客人很多事让她二炮还叫人','2018-02-28 10:34:58','2019-02-24 21:02:58'), ('27','18701817525','神无','67c70763ce38919105acc783fa5e834d','0','18765464985','了PDF你好逗','1','哦【但是若干年后天赋','2018-02-28 10:35:20','2019-02-24 21:03:14'), ('28','15800699208','梦幻之白夜','dfda39bb37573e74338338642162d85b','0','8974@qq.com','工时费','0','好回家哦个积极破解','2018-04-05 23:19:33','2019-02-24 21:03:53'), ('29','11111111111','admin111','d384ece233ea14a88e887d2e0b363753','0','111111111','1111111111111','0','11111111111111','2019-07-25 12:58:58','2019-07-25 12:58:58'), ('31','1231312313','1111','14a5f308f01e71018e9531b2f43dbeb8','0','123123@qq.com','啊手动阀','0','阿迪斯','2019-09-15 12:41:15','2019-09-15 12:41:15'), ('32','13927459802','admin','0838bbf98cc735eda3cab04d098387be','1','330490409@qq.com','','0','','2020-01-27 14:48:44','2020-01-27 14:48:44');
